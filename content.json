{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"天下武功，唯快不破","text":"","link":"/tags/index.html"}],"posts":[{"title":"leetcode 1-50","text":"最近更新： 2020-6-6 upds。 1. 两数之和Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 这个是没有用到字典的代码，虽然实现了上述功能但是，时间花费很多。 12345678910&gt;class Solution:&gt;def twoSum(self, nums,target):&gt;for i in nums:&gt; j=target-i&gt; start_index = nums.index(i)&gt; next_index = start_index+1&gt; temp_nums = nums[next_index:] //将从next_index到最后最后这些元素新建一个Array&gt; if j in temp_nums: //判断一下j是否在temp_nums这个数组中&gt; return(nums.index(i),next_index+temp_nums.index(j))&gt; 1234567891011121314151617181920212223class Solution { public int[] twoSum(int[] nums, int target) { if (nums == null || nums.length&lt;2){ return new int[]{-1,-1}; } int[] res=new int []{-1,-1}; //为了存最后的访问结果 HashMap&lt;Integer,Integer &gt; map = new HashMap&lt;&gt;();//定义一个HashMap for(int i =0;i&lt;nums.length;i++){ //遍历这个数组 if (map.containsKey(target-nums[i])){ res[0]= map.get(target-nums[i]); res[1]=i; break; } map.put(nums[i],i); //HashMap存对应的每个值，和index } return res; } public static void main(String[] args){ } } 这段代码主要用到了hashmap的算法，大大提高了效率，但是暂时还不会 9. 回文数题目摘要判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 思路一些一定不为回文数的数：1.负数2.大于0，但末位为0的数（x&gt; 0 &amp;&amp; x % 10 == 0）如果是上面这些情况则直接返回false。 将整数的每一位存入数组中，arr[i]代表整数的倒数i+1位。 然后判断arr[i]是否和arr[num -1 -i]位是否相等，如果相等则判断下一位；否则返回false当i&gt; num-i-1时如果还没返回则代表所有字符的是相对称的，也就是回文数，返回true 下面是python的代码：12345678910111213141516class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" a=abs(x) sum=0 while(a!=0): p=x%10 sum=sum*10+p a=a//10 if x&gt;=0 and x==sum: return True else: return False 下面是高级版python代码：希望以后再回来看将它弄懂1234class Solution: def isPalindrome(self, x: int) -&gt; bool: r = list(map(lambda i: int(10**-i * x % 10), range(int(math.log10(x)), -1, -1))) if x &gt; 0 else [0, x] return r == r[::-1] 下面是java的代码：简单暴力型的主要是用到java自带的函数： 1234567///简单粗暴，看看就行class Solution { public boolean isPalindrome(int x) { String reversedStr = (new StringBuilder(x + \"\")).reverse().toString(); return (x + \"\").equals(reversedStr); }} 解法二：进阶解法—数学解法通过取整和取余操作获取整数中对应的数字进行比较。 举个例子：1221 这个数字。具体做法如下： 通过计算 1221 / 1000， 得首位1 通过计算 1221 % 10， 可得末位 1 进行比较 再将 22 取出来继续比较 1234567891011121314151617class Solution { public boolean isPalindrome(int x) { //定义一个布尔类型的方法 //边界判断 if (x &lt; 0) return false; int div = 1; // while (x / div &gt;= 10) div *= 10; while (x &gt; 0) { int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; } return true; }} 解法三：进阶解法—巧妙解法直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。 所以这个解法的操作就是 取出后半段数字进行翻转。 这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。 具体做法如下： 每次进行取余操作 （ %10），取出最低的数字：y = x % 10 将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y 每取一个最低位数字，x 都要自除以 10 判断 x 是不是小于revertNum ，当它小于的时候，说明数字已经对半或者过半了 最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数 字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。 123456789101112class Solution { public boolean isPalindrome(int x) { //思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; int revertedNumber = 0; while (x &gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; }} 14. 最长公共前缀难度 easy 题目名称 题目摘要编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出:&quot;&quot;解释: 输入不存在公共前缀。 思路首先判断字符串是否为空，如果是直接输出&quot;&quot;之后建立两个for循环，第一层循环是遍历第一个字符串，第二个循环是从第二个字符串开始和第一个字符串进行比较，这里有一些反常，就是不满足条件就退出。这个条件是i大于字符串的长度，或者就是遇到不相等的了，返回这个前缀，当然如果是一个空字符串，就返回&quot;&quot;123456789class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return\"\" for i in range(len(strs[0])): for string in strs[1:]: #从列表中第一个位置与第0的位置比较 if i&gt;=len(string) or string[i] != strs[0][i] : #就是遍历的i大于单词的长度 return strs[0][:i] return strs[0] #如果是一个[\"\"],这种情况下返回第一个字符 下面是高级一些的python代码： 思路2我先设置一个空的字符串，1234567891011121314151617class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: result =\"\" i=0 while True: try: sets=set(string[i]for string in strs)#因为set是集合的概念，遍历这个列表的每一个字符串的第i位，输出的都是不同的值，如果相同就输出一个， if len(sets)==1: #如果对应位置不是同一个字符，那么就不会是1 result+=sets.pop()# pop是出栈的意思，后进后出（当然也只有一个元素）弹出加在result后面 i+=1#在去检查下一个字符 else: break except Exception as e: # break return result $$ —- \\mathcal{End} —- $$","link":"/2019/07/12/leetcode1-50/"},{"title":"2.数据库基础-DML&DDL","text":"最近更新： 2020-6-8 upds。 DML-数据操作语言插入：insert修改：update删除：delete 1.插入语句 方式一：经典的插入语法：insert into 表名(列名,…) values(值1,…); 1.插入的值的类型要与列的类型一致或兼容 12INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)VALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2); 2.不可以为null的列必须插入值。可以为null的列如何插入值？ 方式一：令其为null 12INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)VALUES(13,'唐艺昕','女','1990-4-23','1898888888',NULL,2); #方式二：可以为空的，不写就好 12INSERT INTO beauty(id,NAME,sex,phone)VALUES(15,'娜扎','女','1388888888'); 3.列的顺序是可以调换，但是value一定要一一对应 12INSERT INTO beauty(NAME,sex,id,phone)VALUES('蒋欣','女',16,'110'); 4.列数和值的个数必须一致 12INSERT INTO beauty(NAME,sex,id,phone)VALUES('关晓彤','女',17,'120'); 5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致，可以的 12INSERT INTO beautyVALUES(18,'张飞','男',NULL,'119',NULL,NULL); 方式二：语法：insert into 表名set 列名=值,列名=值,… 12INSERT INTO beautySET id=19,NAME='刘涛',phone='999'; 两种方式大pk ：1、方式一支持插入多行,方式二不支持 1234INSERT INTO beautyVALUES(23,'唐艺昕1','女','1990-4-23','1898888888',NULL,2),(24,'唐艺昕2','女','1990-4-23','1898888888',NULL,2),(25,'唐艺昕3','女','1990-4-23','1898888888',NULL,2); 2、方式一支持子查询，方式二不支持 先执行SELECT 26,'宋茜','11809866';查出来的结果在进行insert 12INSERT INTO beauty(id,NAME,phone)SELECT 26,'宋茜','11809866'; 先从boys中查询出结果，然后进行插入， 123INSERT INTO beauty(id,NAME,phone)SELECT id,boyname,'1234567'FROM boys WHERE id&lt;3; 2. 修改语句1.修改单表的记录★ 语法：update 表名set 列=新值,列=新值,…where 筛选条件; 2.修改多表的记录【补充】 语法：sql92语法：update 表1 别名,表2 别名set 列=值,…where 连接条件and 筛选条件; sql99语法：update 表1 别名inner|left|right join 表2 别名on 连接条件set 列=值,…where 筛选条件; 1.修改单表的记录案例1：修改beauty表中姓唐的女神的电话为13899888899 12UPDATE beauty SET phone = '13899888899'WHERE NAME LIKE '唐%'; 案例2：修改boys表中id好为2的名称为张飞，魅力值 10 12UPDATE boys SET boyname='张飞',usercp=10WHERE id=2; 2.修改多表的记录 #案例 1：修改张无忌的女朋友的手机号为114 1234UPDATE boys boINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`SET b.`phone`='114'WHERE bo.`boyName`='张无忌'; #案例2：修改没有男朋友的女神的男朋友编号都为2号 12345UPDATE boys boRIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`SET b.`boyfriend_id`=2WHERE bo.`id` IS NULL;SELECT * FROM boys; 3. 删除语句方式一：delete 语法： 1、单表的删除【★】delete from 表名 where 筛选条件 2、多表的删除【补充】 sql92语法：delete 表1的别名,表2的别名from 表1 别名,表2 别名where 连接条件and 筛选条件; sql99语法： delete 表1的别名,表2的别名from 表1 别名inner|left|right join 表2 别名 on 连接条件where 筛选条件; 方式二：truncate 语法：truncate table 表名; 方式一：delete1.单表的删除案例：删除手机号以9结尾的女神信息 12DELETE FROM beauty WHERE phone LIKE '%9';SELECT * FROM beauty; 2.多表的删除案例：删除张无忌的女朋友的信息 1234DELETE bFROM beauty bINNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`WHERE bo.`boyName`='张无忌'; 案例：删除黄晓明的信息以及他女朋友的信息 1234DELETE b,boFROM beauty bINNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`WHERE bo.`boyName`='黄晓明'; 方式二：truncate语句案例：将魅力值&gt;100的男神信息删除，其实是做不到的，因为不可能在后面加上where，所以truncate也被叫做清空数据 1TRUNCATE TABLE boys ; delete pk truncate【面试题】1.delete 可以加where 条件，truncate不能加 2.truncate删除，效率高一丢丢3.假如要删除的表中有自增长列（加入数据自己增长），如果用delete删除后，再插入数据，自增长列的值从断点开始， 而truncate删除后，再插入数据，自增长列的值从1开始。 4.truncate删除没有返回值，delete删除有返回值，告诉你几行被删除了 5.truncate删除不能回滚，delete删除可以回滚. DDL—数据定义语言（库和表的管理 ）库和表的管理 一、库的管理创建、修改、删除二、表的管理创建、修改、删除 创建： create修改： alter删除： drop 一、库的管理1、库的创建语法：create database [if not exists]库名; 案例：创建库Books 1CREATE DATABASE IF NOT EXISTS books ; 2、库的修改 1RENAME DATABASE books TO 新库名; 3.更改库的字符集 1ALTER DATABASE books CHARACTER SET gbk; 4、库的删除 1DROP DATABASE IF EXISTS books; 二、表的管理1.表的创建 ★语法：create table 表名( 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, … 列名 列的类型【(长度) 约束】) 案例：创建表Book 1234567CREATE TABLE book( id INT,#编号 bName VARCHAR(20),#图书名 price DOUBLE,#价格 authorId INT,#作者编号 publishDate DATETIME#出版日期); 1DESC book; 案例：创建表author 12345CREATE TABLE IF NOT EXISTS author( id INT, au_name VARCHAR(20), nation VARCHAR(10)) DESC author; 2. 表的修改语法alter table 表名 add|drop|modify|change column 列名 【列类型 约束】; ①修改列名1ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME; ②修改列的类型或约束1ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP; ③添加新列1ALTER TABLE author ADD COLUMN annual DOUBLE; ④删除列1ALTER TABLE book_author DROP COLUMN annual; ⑤修改表名1ALTER TABLE author RENAME TO book_author; 表的删除 3.表的删除1DROP TABLE IF EXISTS book_author; 通用的写法： 1234DROP DATABASE IF EXISTS 旧库名;CREATE DATABASE 新库名;DROP TABLE IF EXISTS 旧表名;CREATE TABLE 表名(); 4.表的复制先创建一个表 12345INSERT INTO author VALUES(1,'村上春树','日本'),(2,'莫言','中国'),(3,'冯唐','中国'),(4,'金庸','中国'); 1SELECT * FROM Author; 1.仅仅复制表的结构，没有数据1CREATE TABLE copy LIKE author; 2.复制表的结构+数据12CREATE TABLE copy2 SELECT * FROM author; 只复制部分数据 1234CREATE TABLE copy3SELECT id,au_nameFROM author WHERE nation='中国'; 仅仅复制某些字段，因为条件不满足直接是空列 1234CREATE TABLE copy4 SELECT id,au_nameFROM authorWHERE 0; 5.案例讲解 创建表dept1id INT(7)NAME VARCHAR(25) 12345USE test;CREATE TABLE dept1( id INT(7), NAME VARCHAR(25) ); 将表departments中的数据插入新表dept2中，可以跨库去赋值表结构 123CREATE TABLE dept2SELECT department_id,department_nameFROM myemployees.departments; 创建表emp5id INT(7)First_name VARCHAR (25)Last_name VARCHAR(25)Dept_id INT(7) 123456CREATE TABLE emp5(id INT(7),first_name VARCHAR(25),last_name VARCHAR(25),dept_id INT(7)); 将列Last_name的长度增加到50 1ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50); 根据表employees创建employees2 1CREATE TABLE employees2 LIKE myemployees.employees; 删除表emp5 1DROP TABLE IF EXISTS emp5; 将表employees2重命名为emp5 1ALTER TABLE employees2 RENAME TO emp5; 在表dept和emp5中添加新列test_column，并检查所作的操作 1ALTER TABLE emp5 ADD COLUMN test_column INT; 直接删除表emp5中的列 dept_id 12DESC emp5;ALTER TABLE emp5 DROP COLUMN test_column; 三、常见的数据类型数值型：整型特点：① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值③ 如果不设置长度，会有默认的长度长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！ 小数：​ 分类：1.浮点型float(M,D)，double(M,D)​ 2.定点型 dec(M，D)，decimal(M,D) 特点： ①M：整数部位+小数部位D：小数部位如果超过范围，则插入临界值 ②M和D都可以省略如果是decimal，则M默认为10，D默认为0如果是float和double，则会根据插入的数值的精度来决定精度 ③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用字符型： 较短的文本：char、varchar 较长的文本：text、blob（较长的二进制数据） 字符型较短的文本：char，varchar 其他： binary和varbinary用于保存较短的二进制enum用于保存枚举set用于保存集合 较长的文本：textblob(较大的二进制) 特点： 写法 M的意思 特点 空间的耗费 效率 char char（M） 最大的字符数，可以省略，默认为1 固定长度 比较耗费 高 varchar varchar（M） 最大的字符数，不可以省略 可变长度 比较节省 低 枚举：列表中只可以选择一个插入123CREATE TABLE tab_char( c1 ENUM('a','b','c')); 12345INSERT INTO tab_char VALUES('a');INSERT INTO tab_char VALUES('b');INSERT INTO tab_char VALUES('c');INSERT INTO tab_char VALUES('m');INSERT INTO tab_char VALUES('A'); 1SELECT * FROM tab_char; 因为A和m超出类型所以就显示为空 Set集合类型 和Enum类似，里面只可以保存0~64个成员，区别：Set一次可以选取多个成员，而Enum只能选一个根据成员个数不同 因为A和m超出类型所以就显示为空 123CREATE TABLE tab_set( s1 SET('a','b','c','d')); 1234INSERT INTO tab_set VALUES('a');INSERT INTO tab_set VALUES('A,B');INSERT INTO tab_set VALUES('a,c,d');SELECT * FROM tab_set; 四、常见约束含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性 分类：六大约束 NOT NULL：非空，用于保证该字段的值不能为空 比如姓名、学号等，就像挂星星的必选项 DEFAULT:默认，用于保证该字段有默认值 比如性别，默认为男 PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空 比如学号、员工编号等 UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空 比如座位号 CHECK:检查约束【mysql中不支持】 比如年龄、性别 FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值 在从表中添加外键约束，用于引用主表中某列的值 例如：专业id就必须受到专业表的约束，必须在此专业表的范围内，部门编号、工种编号等 添加约束的时机： 1.创建表时 2.修改表时 约束的添加分类：自我感觉列级约束更像是人话，而表级约束更像是函数 列级约束： 六大约束语法上都支持，但外键约束没有效果 表级约束： 除了非空、默认，其他的都支持 12345CREATE TABLE 表名( 字段名 字段类型 列级约束, 字段名 字段类型, 表级约束) 主键和唯一的大对比： ​ 保证唯一性 是否允许为空 一个表中可以有多少个 是否允许组合 主键 √ × 至多有1个 √， 但不推荐 唯一 √ √ 可以有多个 √， 但不推荐外键： 1、要求在从表设置外键关系 2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求 3、主表的关联列必须是一个key（一般是主键或唯一） 4、插入数据时，先插入主表，再插入从表 删除数据时，先删除从表，再删除主表 1. 添加列级约束语法： 直接在字段名和类型后面追加 约束类型即可。可以添加多个列级约束 只支持：默认、非空、主键、唯一 12345678910USE students;DROP TABLE stuinfo;CREATE TABLE stuinfo( id INT PRIMARY KEY,#主键 stuName VARCHAR(20) NOT NULL UNIQUE,#非空 gender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查 seat INT UNIQUE,#唯一 age INT DEFAULT 18,#默认约束 majorId INT REFERENCES major(id)#外键); 1234CREATE TABLE major( id INT PRIMARY KEY, majorName VARCHAR(20)); 查看stuinfo中的所有索引，包括主键、外键、唯一 1SHOW INDEX FROM stuinfo; 2.添加表级约束语法：在各个字段的最下面 【constraint 约束名】 约束类型(字段名) 1234567891011121314DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, CONSTRAINT pk PRIMARY KEY(id),#主键 CONSTRAINT uq UNIQUE(seat),#唯一键 CONSTRAINT ck CHECK(gender ='男' OR gender = '女'),#检查 CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键);SHOW INDEX FROM stuinfo; 可以去掉前面的设置名称： 12345678910111213DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, PRIMARY KEY(id),#主键 UNIQUE(seat),#唯一键 CHECK(gender ='男' OR gender = '女'),#检查 FOREIGN KEY(majorid) REFERENCES major(id)#外键); 通用的写法： 123456789CREATE TABLE IF NOT EXISTS stuinfo( id INT PRIMARY KEY, stuname VARCHAR(20), sex CHAR(1), age INT DEFAULT 18, seat INT UNIQUE, majorid INT, CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)); 3. 主键和唯一的大对比： 保证唯一性 是否允许为空 一个表中可以有多少个 是否允许组合 主键 √ × 至多有1个 √，但不推荐（多个列组合成一个） 唯一键 √ √ 可以有多个 √，但不推荐 外键： 1、要求在从表设置外键关系 2、从表的外键列的类型和主表（引用的表）的关联列的类型要求一致或兼容，名称无要求 3、主表的关联列必须是一个key（一般是主键 primary key或唯一 unique） 4、插入数据时，先插入主表，再插入从表（有了专业在招学生） 删除数据时，先删除从表，再删除主表 4. 修改表时添加约束1、添加列级约束 1alter table 表名 modify column 字段名 字段类型 新约束; 案例：首先创建表 12345678910DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT)DESC stuinfo; 添加非空约束，使得 1ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL; 2、添加表级约束 1alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】; 添加默认约束 1ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18; 3.添加主键①列级约束（把id添加为主键） 1ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY; ②表级约束（把id添加为主键） 1ALTER TABLE stuinfo ADD PRIMARY KEY(id); 4.添加唯一 ①列级约束 1ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE; ②表级约束 1ALTER TABLE stuinfo ADD UNIQUE(seat); #5.添加外键 1ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 5、修改表时删除约束1.删除非空约束 1ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL; #2.删除默认约束，相当于又加了一遍的感觉 1ALTER TABLE stuinfo MODIFY COLUMN age INT ; #3.删除主键 1ALTER TABLE stuinfo DROP PRIMARY KEY; #4.删除唯一 1ALTER TABLE stuinfo DROP INDEX seat; #5.删除外键 12ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;SHOW INDEX FROM stuinfo; 五、标识列又称为自增长列含义：可以不用手动的插入值，系统提供默认的序列值 特点：1、标识列必须和主键搭配吗？不一定，但要求是一个key2、一个表可以有几个标识列？至多一个！3、标识列的类型只能是数值型，一般是int4、标识列可以通过 SET auto_increment_increment=3;设置步长可以通过 手动插入值，设置起始值 一、创建表时设置标识列，通过auto_increment可以实现自增长 12345DROP TABLE IF EXISTS tab_identity;CREATE TABLE tab_identity( id INT primary key auto_increment, NAME varchar(20)); 设置步长和起始值（MySQL不支持） 1SHOW VARIABLES LIKE '%auto_increment%'; 设置步长值为3： 1SET auto_increment_increment=3; $$ —- \\mathcal{End} —- $$","link":"/2020/06/08/数据库/2.数据库基础-DML&DDL /"},{"title":"equals和\"==\"","text":"最近更新： 2020-5-6 equals和==（基本数据类型、引用、String）1. 必备知识： equals方法最初是在所有类的基类Object中进行定义的，源码是 123public boolean equals(Object obj) { return (this == obj); } 1.1 特殊的String:String s=”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。以String s=”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象,如果有,就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象,如果没有,则在常量池中新创建一个”abcd”,下一次如果有String s1 = “abcd”;又会将s1指向”abcd”这个对象,即以这形式声明的字符串,只要值相等,任何多个引用都指向同一对象。 而String s = new String(“abcd”);和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。 也可以这么理解: String str = “hello”; 先在内存中找是不是有”hello”这个对象,如果有，就让str指向那个”hello”.如果内存里没有”hello”，就创建一个新的对象保存”hello”. String str=new String (“hello”) 就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。 1、两个对象，必然会在堆空间中创建”ab”对象，同时也会在常量池中放”ab” 一个对象是：new关键字在堆空间创建的 另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc 2、new String(“a”) + new String(“b”)呢？ 对象1：new StringBuilder() 对象2： new String(“a”) 对象3： 常量池中的”a” 对象4： new String(“b”) 对象5： 常量池中的”b” 一、基本数据类型存放位置：所有的基本dao数据类型全du部是存储在栈里面，速度快。 equal和==：数据大小确定，内存空间大小可以分配，它们是直接按值存放的，所以可以直接按值访问。他们之间的比较直接选择==，这里直接比较的是他们的值，equal也是一样的。 二.引用数据类型 ==比较两个对象在内存里是不是同一个对象，就是说在内存里的存储位置一致。 两个String对象存储的值是一样的，但有可能在内存里存储在不同的地方. ==比较的是引用而equals方法比较的是内容。 public boolean equals(Object obj)这个方法是由Object对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回true,这个时候和==是等价的。String, BitSet, Date,和File都对equals方法进行了重写，对两个String对象而言，值相等意味着它们包含同样的字符序列。对于基本类型的包装类说，值相等意味着对应的基本类型的值一样。 三、字符串缓冲池1234String s1 = \"hello\"; String s2 = \"hello\"; System.out.println(s1 == s2);//true System.out.println(s1.equals(s2));//true 原来，程序在运行的时候会创建一个字符串缓冲池（字符串常量池）当使用 s2 = “hello” 这样的表达是创建字符串的时候，程序首先会在字符串常量池寻找，s1先被放到了池中，所以在s2被创建的时候，程序找到了具有相同值的 s1 将s2引用s1所引用的对象”hello”； 1234String s1 = \"hello\"; String s2 = new String(\"hello\");System.out.println(s1==s2);//falseSystem.out.println(s1.equals(s2));//true 然而 第二段程序中，使用了 new 操作符，必然会在堆空间中创建”hello”对象，同时也会在字符串常量池中放”hello”存中（因为已经存在所以没有放）。他们的值相同，但是位置不同，由此他们的地址值发生了改变！ 简单总结：==： 1、比较的是操作符两端的操作数是否是同一个对象。 2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。 3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。 equals： equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行重写的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。 equals和==的区别equals方法最初是在所有类的基类Object中进行定义的，源码是 123public boolean equals(Object obj) { return (this == obj); } 由equals的源码可以看出这里定义的equals与==是等效的（Object类中的equals没什么区别），不同的原因就在于有些类（像String、Integer等类）对equals进行了重写，但是没有对equals进行重写的类（比如我们自己写的类）就只能从Object类中继承equals方法，其equals方法与==就也是等效的，除非我们在此类中重写equals。 对equals重新需要注意五点： 1 自反性：对任意引用值X，x.equals(x)的返回值一定为true； 2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true； 3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true ； 4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变； 5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。 另外，”==”比”equals”运行速度快,因为”==”只是比较引用。 $$ —- \\mathcal{End} —- $$","link":"/2020/05/06/java/equals和==（基本数据类型、引用、String）/"},{"title":"3.数据库的设计","text":"最近更新： 2020-6-9 upds。 数据库设计的范式概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 分类： 第一范式（1NF）：每一列都是不可分割的原子数据项 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 几个概念： 函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号–&gt;姓名。 （学号，课程名称） –&gt; 分数 完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） –&gt; 分数 部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） – &gt; 姓名 传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号–&gt;系名，系名–&gt;系主任 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） 主属性：码属性组中的所有属性 非主属性：除过码属性组的属性 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原1. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径 2. 图形化工具： $$ —- \\mathcal{End} —- $$","link":"/2020/06/09/数据库/3.数据库的设计/"},{"title":"Markdown基础","text":"1 文字内容部分1.1 标题 Markdown支持6种级别的标题，对应html标签 h1 ~ h6 123456# h1## h2### h3#### h4##### h5###### h6 以上标记效果如下：！标题 除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 Setext 标记语言的表现形式，使用下划线进行文本大小的控制1234这是一级标题===这是二级标题--- 1.2 区块引用而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示1&gt; 这段文字将被高亮显示... 以上标记效果如下： 这段文字将被高亮显示… 1.3 标题居中/图3 全连接层 效果如下: 图3 全连接层 1.4 列表Markdown支持有序列表和无序列表两种形式： 无序列表使用*或+或-标识有序列表使用数字加.标识，例如：1. 黄瓜1234567891011121314* 玉米* 茄子+ 黄瓜+ 玉米+ 茄子- 黄瓜- 玉米- 茄子1. 黄瓜2. 玉米3. 茄子 以上标记效果如下： 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 注：这里比较有趣的地方是，对于有序列表，Markdown将只关注你的第一个项目的数字编号。例如：如果第一个项目编号是3，以此类推，第二个项目应该是4，最终将显示为3、4、5。而如果你指定了第一个编号，后面的编号指定错误也没有关系，Markdown将只在乎你的第一个项目编号。 1.4.1 使用列表的注意事项如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格 123456* 段落一 小段一* 段落二 小段二 以上标记效果如下： 段落一 小段一 段落二 小段二 另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格 1234* 段落一 &gt; 区块标记一* 段落二 &gt; 区块标记二 以上标记效果如下： 段落一 区块标记一 段落二 区块标记二 注：记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。 1.5 强调有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗。 12345*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__ 以上标记效果如下： 这里是斜体这里是斜体 这里是加粗这里是加粗 1.6 插入代码块Markdown在IT圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码。方法是，使用反引号进行包裹即可。如果是行内代码引用，使用单个反引号进行包裹这是一段var x = 3行内代码如果插入一整段代码，需要至少使用两个以上反引号进行包裹， 看效果： 123fun (x: Int, y: Int): Int { return x + y} 当然typora使用快捷键ctrl+shift+k可以快速解决 1.7 插入表格表格是Markdown语法中比较复杂的一个，其语法如下： 123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 显示效果如下： 表头 条目一 条目二 项目 项目一 项目二 注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 1.8 特殊符号处理Markdown使用反斜杠\\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理： 123456789101112\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：\\ =&gt; \\ 。注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。 2 链接图片样式2.1 插入图片和引用链接Markdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记12[点击跳转至百度](http://www.baidu.com)![图片](https://upload-images.jianshu.io/upload_images/703764-605e3cc2ecb664f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 点击跳转至百度 注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。 3 其他3.1 分隔线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以,产生分隔线的语法要求比较松，符号之间添加空格也可以。12***--- 以上标记效果如下： $$ —- \\mathcal{End} —- $$","link":"/2019/05/14/命令行与配置/Markdown笔记/"},{"title":"Numpy语法总结","text":"最近更新： 2020-9-10 第一章.数据IONumPy提供了多种存取数组内容的文件操作函数。保存数组数据的文件可以是二进制格式或者文本格式。二进制格式的文件又分为NumPy专用的格式化二进制类型和无格式类型 一，tofile()和fromfile() tofile()将数组中的数据以二进制格式写进文件 tofile()输出的数据不保存数组形状和元素类型等信息 fromfile()函数读回数据时需要用户指定元素类型，并对数组的形状进行适当的修改 从上面的例子可以看出，在读入数据时:需要正确设置dtype参数，并修改数组的shape属性才能得到和原始数据一致的结果。无论数据的排列顺序是C语言格式还是Fortran语言格式，tofile()都统一使用C语言格式输出。此外如果指定了sep参数，则fromfile()和tofile()将以文本格式对数组进行输入输出。sep参数指定的是文本数据中数值的分隔符。 二.save()和load()save（）1234567891011121314151617from tempfile import TemporaryFileoutfile = TemporaryFile()x = np.arange(10)np.save(outfile, x)_ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening filenp.load(outfile)#结果：array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])with open(&apos;test.npy&apos;, &apos;wb&apos;) as f: np.save(f, np.array([1, 2])) np.save(f, np.array([1, 3]))with open(&apos;test.npy&apos;, &apos;rb&apos;) as f: a = np.load(f) b = np.load(f)print(a, b)# [1 2] [1 3] 如果想将多个数组保存到一个文件中，可以使用savez() savez()的第一个参数是文件名，其后的参数都是需要保存的数组，也可以使用关键字参数为数组起名 非关键字参数传递的数组会自动起名为arr_0、arr_1、…。 savez()输出的是一个扩展名为npz的压缩文件，其中每个文件都是一个save()保存的npy文件，文件名和数组名相同 load()自动识别npz文件，并且返回一个类似于字典的对象，可以通过数组名作为键获取数组的内容 12 第二章数据类型固定长度的整型，包括有符号整型或无符号整型。 1.整型整型范围 Int8 - [-128 : 127] Int16 - [-32768 : 32767] Int32 - [-2147483648 : 2147483647] Int64 - [-9223372036854775808 : 9223372036854775807] 无符号整型范围 UInt8 - [0 : 255] UInt16 - [0 : 65535] UInt32 - [0 : 4294967295] UInt64 - [0 : 18446744073709551615] 2.浮点数据类型single数据类型存储有符号的 IEEE 格式 32 位（4 个字节）单精度浮点数，负数取值范围为 －3.4028235E+38～－1.401298E－45，正数取值范围为 1.401298E－45 到 3.4028235E+38。单精度数值存储实数数值的近似值。 3.nan值数据类型12345678910111213&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; l=np.array([[1,2],[2,3],[np.nan,3]])&gt;&gt;&gt; larray([[ 1., 2.], [ 2., 3.], [nan, 3.]])&gt;&gt;&gt; l.mean()nan&gt;&gt;&gt; l[np.isnan(l)]=0&gt;&gt;&gt; larray([[1., 2.], [2., 3.], [0., 3.]]) 第三章数组形状1改变数组形状1.1将数组变为具体的形状reshape(shape) ： 不改变数组元素，返回一个shape形状的数组，原数组不变。是对每行元素进行处理resize(shape) ： 与.reshape()功能一致，但修改原数组 1234567891011121314151617181920212223In [1]: a = np.arange(20)#原数组不变In [2]: a.reshape([4,5])Out[2]:array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]) In [3]: aOut[3]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) #修改原数组In [4]: a.resize([4,5]) In [5]: aOut[5]:array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]) .swapaxes(ax1,ax2) ： 将数组n个维度中两个维度进行调换，不改变原数组 1234567In [6]: a.swapaxes(1,0)Out[6]:array([[ 0, 5, 10, 15], [ 1, 6, 11, 16], [ 2, 7, 12, 17], [ 3, 8, 13, 18], [ 4, 9, 14, 19]]) 1.2将多维数组转为一维数组ravel()：如果没有必要，不会产生源数据的副本flatten()：返回源数据的副本squeeze()：只能对维数为1的维度降维 另外，reshape(-1)也可以“拉平”多维数组 $$ —- \\mathcal{End} —- $$","link":"/2020/08/12/python/Numpy语法总结/"},{"title":"1.数据库基础—DQL","text":"最近更新： 2020-6-6 upds。 数据库基础—DQL基础概念数据库语言分类 DQL（Data Query Language）：数据查询语言 selectDML(Data Manipulate Language):数据操作语言 insert 、update、deleteDDL（Data Define Languge）：数据定义语言 create、drop、alterTCL（Transaction Control Language）：事务控制语言 commit、rollback UTF-8和gb2312的区别#utf8默认一个字母占一个字节，一个汉字占3个字节。 1.基础查询&amp;条件查询1.筛选条件的分类1、简单条件运算符>, &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;安全等于 2、逻辑运算符等价于&amp;&amp; and等价于|| or等价于! not 3、模糊查询like:一般搭配通配符使用，可以判断字符型或数值型通配符：%任意多个字符，_任意单个字符 between andin 案例：查询部门编号不等于90号的员工名和部门编号 1234567select last_name, department_idFROM employeesWHERE department_id&lt;&gt;90; 案例：查询工资z在10000到20000之间的员工名、工资以及奖金 12345678SELECT last_name, salary, commission_pctFROM employeesWHERE salary&gt;=10000 AND salary&lt;=20000; 案例：查询部门编号不是在90到110之间，或者工资高于15000的员工信息 123456SELECT *FROM employeesWHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000; 案例：查询员工名中包含字符a的员工信息 123456select *from employeeswhere last_name like '%a%'; 案例：查询员工名中第三个字符为e，第五个字符为a的员工名和工资 1234567SELECT last_name, salaryFROM employeesWHERE last_name LIKE '__e_a%'; 案例：查询员工名中第二个字符为_的员工名 可以使用/作为转义字符；也可以使用任意转义字符如前面的$，这里使用escape目的是使得$没有实际意义； 123456SELECT last_nameFROM employeesWHERE last_name LIKE '_$_%' ESCAPE '$'; between and包含边界值 案例1：查询员工编号在100到120之间的员工信息 123456SELECT *FROM employeesWHERE employee_id &gt;= 100 AND employee_id&lt;=120; 123456SELECT *FROM employeesWHERE employee_id BETWEEN 100 AND 120; inin列表的值类型必须一致或兼容in列表中不支持通配符 案例：查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号 1234567SELECT last_name, job_idFROM employeesWHERE job_id = 'IT_PROT' OR job_id = 'AD_VP' OR JOB_ID ='AD_PRES'; 1234567SELECT last_name, job_idFROM employeesWHERE job_id IN( 'IT_PROT' ,'AD_VP','AD_PRES'); is null=或&lt;&gt;不能用于判断null值is null或is not null 可以判断null值,这个is not就是和null搭配的不可以用于其他内容 案例1：查询没有奖金的员工名和奖金率 1234567SELECT last_name, commission_pctFROM employeesWHERE commission_pct IS NULL; 1234567SELECT last_name, commission_pctFROM employeesWHERE commission_pct &lt;=&gt;NULL; 案例2：查询工资为17000的员工名和奖金率,注意：不可以用IS而是用17000 123456789SELECT last_name, commission_pct FROM employees WHERE salary &lt;=&gt; 17000; is null /is not null：用于判断null值 is null PK &lt;=&gt; IS NULL:仅仅可以判断NULL值，可读性较高，建议使用&lt;=&gt; :既可以判断NULL值，又可以判断普通的数值，可读性较低 普通类型的数值 null值 可读性 is null × √ √ &lt;=&gt; √ √ × 案例：查询工号为AD_VP的员工的姓名和部门的号的年薪 12345678SELECT last_name, department_id, salaryFROM employeesWHERE job_id ='AD_VP'; 案例：查询没有奖金，且工资小于18000的salary，last_name 1234567SELECT salary, last_nameFROM employeesWHERE commission_pct IS NULL AND salary&lt;18000; 案例：查询employees表中，job_id不为‘AD_VP’或者工资为12000的员工信息 12345678SELECT salary, last_name, job_idFROM employeesWHERE job_id &lt;=&gt;'AD_VP' OR salary=18000; 4、快速查询 查看部门 1DESC departments; 查看部门department表中涉及到了哪些编号，DISTINCT具有去重的功能 12SELECT DISTINCT location_idFROM departments 经典面试题： 12SELECT * FROM employees WHERE commission_pct LIKE '%%' AND last_name LIKE '%%'; 1SELECT*FROM employees; 是不一样的，上面的会把null的包含，如果将下面的AND变为or就一样了 2.排序查询一、语法select 查询列表from 表where 筛选条件order by 排序列表 【asc/desc】 1、asc ：升序，如果不写默认升序 desc：降序 2、排序列表 支持 单个字段、多个字段、函数、表达式、别名 3、order by的位置一般放在查询语句的最后（除limit语句之外） 1. 按单个字段排序 案例：查询工资薪水按照降序排列 12SELECT * FROM employees ORDER BY salary DESC; 2. 添加筛选条件再排序 案例：查询部门编号&gt;=90的员工信息，并按员工编号降序（入职的先后顺序） 1234SELECT *FROM employeesWHERE department_id&gt;=90ORDER BY employee_id DESC; 3. 按表达式排序 案例：查询员工信息 按年薪降序 因为1+null等于null，所以需要处理一下，IFNULL(commission_pct,0))，如果不是null就加上奖金 123SELECT *,salary*12*(1+IFNULL(commission_pct,0)) FROM employeesORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; 4.按函数排序 案例：查询员工名，并且按名字的长度降序 123SELECT LENGTH(last_name),last_name ,salaryFROM employeesORDER BY LENGTH(last_name) DESC; 5、按别名排序 案例：查询员工信息 按年薪升序 别名就是年薪，order by后面也是支持别名 123SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employeesORDER BY 年薪 ASC; 6、按多个字段排序 案例：查询员工信息，要求先按工资降序，再按employee_id升序 123SELECT *FROM employeesORDER BY salary DESC,employee_id ASC; 先按照工资进行排序，然后按照员工编号排序（就是当有salary一样的时候，按照employee_id排序） 3.常见函数1. 字符函数2. 数字函数3. 日期函数4. 流程控制函数聚合函数：将一列数据作为一个整体，进行纵向的计算。 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 4. 分组查询一、语法select 分组函数，分组后的字段from 表【where 筛选条件】例如：奖金不为空group by 分组的字段 例如：按照工种分【having 分组后的筛选】例如：员工个数大于5【order by 排序列表】例如：按照薪水降序 使用关键字 筛选的表 位置 分组前筛选 where 原始表 group by的前面 分组后筛选 having 分组后结果 group by的后面 案例1：查询每个工种的员工平均工资所以是按照每一种job_id 查询 123SELECT AVG(salary),job_idFROM employeesGROUP BY job_id; 案例2：查询每个位置的部门个数 123SELECT COUNT(*),location_idFROM departmentsGROUP BY location_id; 1. 可以实现分组前的筛选 案例1：查询邮箱中包含a字符的 每个部门的最高工资（只在email中有a的中筛选） 1234SELECT MAX(salary),department_idFROM employeesWHERE email LIKE '%a%'GROUP BY department_id; 案例2：查询有奖金的每个领导手下员工的平均工资 1234SELECT AVG(salary),manager_idFROM employeesWHERE commission_pct IS NOT NULLGROUP BY manager_id; 2. 分组后筛选 案例1：查询哪个部门的员工个数&gt;5 ①查询每个部门的员工个数 123SELECT COUNT(*),department_idFROM employeesGROUP BY department_id; #② 筛选刚才①结果 1234SELECT COUNT(*),department_idFROM employeesGROUP BY department_idHAVING COUNT(*)&gt;5; 案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资 12345SELECT job_id,MAX(salary)FROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING MAX(salary)&gt;12000; 案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资 12345SELECT manager_id,MIN(salary)FROM employeesWHERE manager_id&gt;102GROUP BY manager_idHAVING MIN(salary)&gt;5000; 3. 添加排序 案例：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序 123456SELECT job_id,MAX(salary) mFROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING m&gt;6000ORDER BY m ; 4. 按多个字段分组#案例：查询每个工种每个部门的最低工资,并按最低工资降序 1234SELECT MIN(salary),job_id,department_idFROM employeesGROUP BY department_id,job_idORDER BY MIN(salary) DESC; 5. 连接查询一、含义当查询中涉及到了多个表的字段，需要使用多表连接select 字段1，字段2from 表1，表2,…; 笛卡尔乘积：当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接如何解决：添加有效的连接条件 按年代分类： sql92标准:仅仅支持内连接（等值、非等值、和自连接） sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接 按功能分类： 内连接：等值连接，非等值连接，自连接 外连接： 左外连接，右外连接，全外连接 交叉连接 1. 等值连接① 多表等值连接的结果为多表的交集部分②n表连接，至少需要n-1个连接条件③ 多表的顺序没有要求④一般需要为表起别名⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选 案例1：查询女神名和对应的男神名 123SELECT NAME,boyName FROM boys,beautyWHERE beauty.boyfriend_id= boys.id; 案例2：查询员工名和对应的部门名 123SELECT last_name,department_nameFROM employees,departmentsWHERE employees.`department_id`=departments.`department_id`; 1. 为表起别名①提高语句的简洁度②区分多个重名的字段 注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定 查询员工名、工种号、工种名 123SELECT e.last_name,e.job_id,j.job_titleFROM employees e,jobs jWHERE e.`job_id`=j.`job_id`; 2. 两个表的顺序是否可以调换查询员工名、工种号、工种名 123SELECT e.last_name,e.job_id,j.job_titleFROM jobs j,employees eWHERE e.`job_id`=j.`job_id`; 3. 可以加筛选 案例1：查询有奖金的员工名、部门名 1234SELECT last_name,department_name,commission_pctFROM employees e,departments dWHERE e.`department_id`=d.`department_id`AND e.`commission_pct` IS NOT NULL; 案例2：查询城市名中第二个字符为o的部门名和城市名 1234SELECT department_name,cityFROM departments d,locations lWHERE d.`location_id` = l.`location_id`AND city LIKE '_o%'; 案例3：查询每个城市的部门个数 1234SELECT COUNT(*) 个数,cityFROM departments d,locations lWHERE d.`location_id`=l.`location_id`GROUP BY city; 案例4：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资 12345SELECT department_name,d.`manager_id`,MIN(salary)FROM departments d,employees eWHERE d.`department_id`=e.`department_id`AND commission_pct IS NOT NULLGROUP BY department_name,d.`manager_id`; 4. 可以加排序案例：查询每个工种的工种名和员工的个数，并且按员工个数降序 12345SELECT job_title,COUNT(*)FROM employees e,jobs jWHERE e.`job_id`=j.`job_id`GROUP BY job_titleORDER BY COUNT(*) DESC; 5.可以实现三表连接 案例：查询员工名、部门名和所在的城市 123456SELECT last_name,department_name,cityFROM employees e,departments d,locations lWHERE e.`department_id`=d.`department_id`AND d.`location_id`=l.`location_id`AND city LIKE 's%'ORDER BY department_name DESC; 2. 非等值连接 案例1：工的工资级别 1234SELECT salary,grade_levelFROM employees eJOIN job_grades gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`; 对比sql92的格式： 123SELECT salary,grade_levelFROM employees e,job_grades gWHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`; 案例2：资级别的个数&gt;20的个数，并且按工资级别降序 1234567SELECT COUNT(*),grade_levelFROM employees eJOIN job_grades gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`GROUP BY grade_levelHAVING COUNT(*)&gt;20ORDER BY grade_level DESC; 3. 自连接自己连接自己 案例：查询 员工名和上级的名称 123SELECT e.employee_id,e.last_name,m.employee_id,m.last_nameFROM employees e,employees mWHERE e.`manager_id`=m.`employee_id`; 从上表可以看出k_ing的emplyee_id是100，kochhar的manage_id是100，所以kochhar的领导是k_ing，所以结果如下： 4. 外连接应用场景：用于查询一个表中有，另一个表没有的记录 特点： 1、外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的，则显示匹配的值 如果从表中没有和它匹配的，则显示null 外连接查询结果=内连接结果+主表中有而从表没有的记录 2、左外连接，left join左边的是主表 右外连接，right join右边的是主表 3、左外和右外交换两个表的顺序，可以实现同样的效果 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的 如果仅仅是下面这样查询就只是笛卡尔乘积，出现很多的null 12 SELECT * FROM beauty; SELECT * FROM boys; 你要查询的信息主要在那个表，那个表就是主表。 左外连接，可以看出beauty是主表，左外连接了boy表，条件是b.boyfriend_id = bo.id 1234SELECT b.name,bo.*FROM beauty bLEFT OUTER JOIN boys boON b.`boyfriend_id` = bo.`id` 筛选出没有男朋友的beauty，分别用左外右外连接实现 左外连接 12345SELECT b.name,bo.*FROM beauty bLEFT OUTER JOIN boys boON b.`boyfriend_id` = bo.`id`WHERE bo.`id` IS NULL; 右外连接（只需要修改几处即可） 12345SELECT b.name,bo.*FROM boys boright OUTER JOIN beauty bON b.`boyfriend_id` = bo.`id`WHERE bo.`id` IS NULL; 案例1：查询哪个部门没有员工 左外(LEFT OUTER JOIN 的左边是主表) 12345SELECT d.*,e.employee_idFROM departments dLEFT OUTER JOIN employees eON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL; 右外 结果同上 12345SELECT d.*,e.employee_idFROM employees eRIGHT OUTER JOIN departments dON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL; 全外全外就是不分主从表，首先两部分的交集是可以出现的，左外的部分会出现，右外的部分也会出现 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的 6.子查询含义：出现在其他语句中的select语句，称为子查询或内查询，外部的查询语句，称为主查询或外查询 特点：①子查询放在小括号内②子查询一般放在条件的右侧③标量子查询，一般搭配着单行操作符使用> &lt; &gt;= &lt;= = &lt;&gt; 列子查询，一般搭配着多行操作符使用in、any/some、all ④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果 1.标量子查询#案例1：谁的工资比 Abel 高? ①查询Abel的工资 123SELECT salaryFROM employeesWHERE last_name = 'Abel' #②查询员工的信息，满足 salary&gt;①结果 1234567SELECT *FROM employeesWHERE salary&gt;( SELECT salary FROM employees WHERE last_name = 'Abel'); #案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资 2.列子查询（多行子查询）一列多行案例：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary ①查询job_id为‘IT_PROG’部门任一工资 123SELECT DISTINCT salaryFROM employeesWHERE job_id = 'IT_PROG' ②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个 1234567SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;ANY( SELECT DISTINCT salary FROM employees WHERE job_id = 'IT_PROG') AND job_id&lt;&gt;'IT_PROG'; 3. 行子查询（结果集一行多列或多行多列） 了解123456SELECT * FROM employeesWHERE (employee_id,salary)=( SELECT MIN(employee_id),MAX(salary) FROM employees); #①查询最小的员工编号 12SELECT MIN(employee_id)FROM employees #②查询最高工资 12SELECT MAX(salary)FROM employees #③查询员工信息 123456789SELECT *FROM employeesWHERE employee_id=( SELECT MIN(employee_id) FROM employees)AND salary=( SELECT MAX(salary) FROM employees); 以下几种情况：select后面仅仅支持标量子查询 案例：查询每个部门的员工个数，牛逼！牛逼！ 123456SELECT d.*,( SELECT COUNT(*) FROM employees e WHERE e.department_id = d.`department_id` ) 个数 FROM departments d; from后面将子查询结果充当一张表，要求必须起别名 有时间将这里在补充一下，重新看一下尚硅谷是视频 exists后面（相关子查询）语法：exists(完整的查询语句) 结果：1或0 1SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000); 如果有的话，结果就是1，如果没有的话，结果是0； #案例1：查询有员工的部门名#in，两种方式，一种是in一种是exist 123456SELECT department_nameFROM departments dWHERE d.`department_id` IN( SELECT department_id FROM employees) 7. 分页查询应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求语法： select 查询列表 from 表 【join type join 表2 on 连接条件 where 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序的字段】 limit 【offset,】size; 案例1：查询前五条员工信息 12SELECT * FROM employees LIMIT 0,5;SELECT * FROM employees LIMIT 5; 案例2：查询第11条——第25条 1SELECT * FROM employees LIMIT 10,15; 8. 联合查询union 联合 合并：将多条查询语句的结果合并成一个结果 语法：查询语句1union查询语句2 应用场景：要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时 特点：1、要求多条查询语句的查询列数是一致的！2、要求多条查询语句的查询的每一列的类型和顺序最好一致3、union关键字默认去重，如果使用union all 可以包含重复项 案例：查询部门编号&gt;90或邮箱包含a的员工信息 1234SELECT * FROM employees WHERE email LIKE '%a%' OR department_id&gt;90;;SELECT * FROM employees WHERE email LIKE '%a%'UNIONSELECT * FROM employees WHERE department_id&gt;90; 案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息 123SELECT id,cname FROM t_ca WHERE csex='男'UNION ALLSELECT t_id,tname FROM t_ua WHERE tGender='male'; $$ —- \\mathcal{End} —- $$","link":"/2020/06/06/数据库/1.数据库基础-DQL/"},{"title":"icarus主题配置","text":"日常操作命令： hexo server : 简写 hexo s #启动服务 hexo generate : 简写 hexo g #生成静态网页 hexo deploy : 简写 hexo d #部署 侧边栏右侧边栏这个是recent我把他改为了“推荐阅读”，打开\\icarus\\layout\\widget\\recent_posts.ejs，找到： 1&lt;% site.posts.sort('date', -1).limit(5).each(post =&gt; { %&gt; 一行，改成： 1&lt;% site.posts.sort('priority', -1).limit(5).each(post =&gt; { %&gt; 然后只需要在每篇文章上面的配置里加上priority: xxx，其中xxx是你自由确定的优先级（1,2,3之类的数字），就可以自由更改显示在那里的文章了。当然也可以调整显示在那里的文章数量，像这样： 1&lt;% site.posts.sort('priority', -1).limit(10).each(post =&gt; { %&gt; 就是显示10篇文章。10也可以改成其它数字。 然后更改栏目名称。打开\\icarus\\languages\\zh-CN.yml，找到： 1recents: '最新文章' 一句，把“最新文章”替换成“阅读推荐”就好了。 侧边栏目录的自动编号这个我暂时没有感觉自动编号对我有什么不舒服，如果以后觉得需要改再弄吧 目录本人一般会手动编号，所以这个自动编号功能对我来说并不友好。所以加个开关好了。 打开\\icarus\\layout\\widget\\toc.ejs，把整个文件复制一遍然后粘贴到最后面。然后会有两行像这样的语句： 1&lt;% if (get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 把第一句改成： 1&lt;% if (get_config('toc_auto_num') === false &amp;&amp; get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 第二句改成： 1&lt;% if ((get_config('toc_auto_num') === true || !has_config('toc_auto_num')) &amp;&amp; get_config('toc') === true &amp;&amp; (post.layout === 'page' || post.layout === 'post')) { 然后找到第一个if语段中如下的位置： 1&lt;span class=\"has-mr-6\"&gt;${toc.index}&lt;/span&gt; 把它注释掉： 1&lt;!--span class=\"has-mr-6\"&gt;${toc.index}&lt;/span--&gt; 然后就可以通过文章前面的toc_auto_num: true/false来控制是不是开启自动编号。 第二种办法：themes/icarus/layout/widget/toc.ejs 12删除第6行代码即可&lt;span class=\"has-mr-6\"&gt;${toc.index}&lt;/span&gt; 关注改为关于这个东西对我来说也没什么用处。把它链接到关于页面之后，在\\icarus\\languages\\zh-CN.yml里，找到： 1follow: &apos;关注&apos; 一句，改成： 1follow: &apos;关于&apos; 然后更改页面打开方式为同一页面跳转，具体做法是打开\\icarus\\layout\\widget\\profile.ejs，找到： 123&lt;a class=\"level-item button is-link is-rounded\" href=\"&lt;%= url_for(widget.follow_link) %&gt;\" target=\"_blank\"&gt; &lt;%= __('widget.follow') %&gt;&lt;/a&gt; 把target=&quot;_blank&quot;属性删掉就好了。 站底数字统计主题是默认支持BuSuanZi，只需要在配置文件中把busuanzi 改为true即可。 在本机通过http://localhost/访问会发现访客数很大，我百度后说是发布到服务器上就好了。确实是。 初步感觉应该是按照IP为维度来分的，大家本机访问域名都是localhost，所以访客数不断累积。放到自己服务器就重新计算了。 站点推送分享插件隐藏首页文章文章里面改动文章发表时间修改 如果文章发布时间较早，那么默认会显示一年前两年前等，看着不是很美观，于是全部修改为发表的年月日。源码中改动如下： themes/icarus/layout/common/article.ejs 12第14行&lt;span class=&quot;level-item has-text-grey&quot;&gt;写于&lt;%= date(post.date) %&gt;&lt;/span&gt; 添加评论系统之前的WordPress用的是内置评论系统，现在主题里支持很多第三方的评论系统。我采用的是valine，具体配置详见官方文档。 $$ —- \\mathcal{End} —- $$","link":"/2020/07/20/命令行与配置/icarus主题配置/"},{"title":"5.常见约束&TCL事务控制语言","text":"最近更新： 2020-6-6 upds。 常见约束含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性 分类：六大约束 NOT NULL：非空，用于保证该字段的值不能为空 比如姓名、学号等 DEFAULT:默认，用于保证该字段有默认值 比如性别 PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空 比如学号、员工编号等 UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空 比如座位号 CHECK:检查约束【mysql中不支持】 比如年龄、性别 FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值 在从表添加外键约束，用于引用主表中某列的值 比如学生表的专业编号，员工表的部门编号，员工表的工种编号 约束的添加分类： 列级约束： 六大约束语法上都支持，但外键约束没有效果 表级约束： 除了非空、默认，其他的都支持 ​ 保证唯一性 是否允许为空 一个表中可以有多少个 是否允许组合 主键 √ × 至多有1个 √， 但不推荐 唯一 √ √ 可以有多个 √， 但不推荐外键： 1、要求在从表设置外键关系 2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求 3、主表的关联列必须是一个key（一般是主键或唯一） 4、插入数据时，先插入主表，再插入从表 删除数据时，先删除从表，再删除主表 一、创建表时添加约束1.添加列级约束语法： 直接在字段名和类型后面追加 约束类型即可。 只支持：默认、非空、主键、唯一 12345678910USE students;DROP TABLE stuinfo;CREATE TABLE stuinfo( id INT PRIMARY KEY,#主键 stuName VARCHAR(20) NOT NULL UNIQUE,#非空 gender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查 seat INT UNIQUE,#唯一 age INT DEFAULT 18,#默认约束 majorId INT REFERENCES major(id)#外键); 1234CREATE TABLE major( id INT PRIMARY KEY, majorName VARCHAR(20)); 查看stuinfo中的所有索引，包括主键、外键、唯一 1SHOW INDEX FROM stuinfo; 2.添加表级约束语法：在各个字段的最下面 【constraint 约束名】 约束类型(字段名) 1234567891011121314DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, CONSTRAINT pk PRIMARY KEY(id),#主键 CONSTRAINT uq UNIQUE(seat),#唯一键 CONSTRAINT ck CHECK(gender ='男' OR gender = '女'),#检查 CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键);SHOW INDEX FROM stuinfo; #通用的写法： 123456789CREATE TABLE IF NOT EXISTS stuinfo( id INT PRIMARY KEY, stuname VARCHAR(20), sex CHAR(1), age INT DEFAULT 18, seat INT UNIQUE, majorid INT, CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)); 二、修改表时添加约束1、添加列级约束alter table 表名 modify column 字段名 字段类型 新约束; 2、添加表级约束alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】; 12345678910DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT)DESC stuinfo; 1.添加非空约束1ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL; 2.添加默认约束1ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18; 3.添加主键①列级约束（把id添加为主键） 1ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY; ②表级约束（把id添加为主键） 1ALTER TABLE stuinfo ADD PRIMARY KEY(id); 4.添加唯一#①列级约束 1ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE; #②表级约束 1ALTER TABLE stuinfo ADD UNIQUE(seat); 5.添加外键1ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 三、修改表时删除约束1.删除非空约束1ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL; 2.删除默认约束，相当于又加了一遍的感觉1ALTER TABLE stuinfo MODIFY COLUMN age INT ; 3.删除主键1ALTER TABLE stuinfo DROP PRIMARY KEY; 4.删除唯一1ALTER TABLE stuinfo DROP INDEX seat; 5.删除外键12ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;SHOW INDEX FROM stuinfo; 标识列又称为自增长列含义：可以不用手动的插入值，系统提供默认的序列值特点：1、标识列必须和主键搭配吗？不一定，但要求是一个key2、一个表可以有几个标识列？至多一个！3、标识列的类型只能是数值型4、标识列可以通过 SET auto_increment_increment=3;设置步长可以通过 手动插入值，设置起始值 一、创建表时设置标识列 123456789DROP TABLE IF EXISTS tab_identity;CREATE TABLE tab_identity( id INT primary key auto_increment, NAME varchar(20));TRUNCATE TABLE tab_identity;INSERT INTO tab_identity(id,NAME) VALUES(null,'john');INSERT INTO tab_identity(NAME) VALUES('lucy');SELECT * FROM tab_identity; 1234TRUNCATE TABLE tab_identity;INSERT INTO tab_identity(id,NAME) VALUES(NULL,'john');INSERT INTO tab_identity(NAME) VALUES('lucy');SELECT * FROM tab_identity; 设置步长和起始值（MySQL不支持） 1SHOW VARIABLES LIKE '%auto_increment%'; 设置步长值为3： 1SET auto_increment_increment=3; TCL-Transaction Control Language 事务控制语言事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。 案例：转账 张三丰 1000郭襄 1000 存储引擎： 1、数据用不同的存储技术进行存储，也称为表类型； 2、通过show engines;来查看mysql支持的存储引擎 3、mysql主流的存储引擎是innodb、myisam、memory，但是后两者不支持事务； update 表 set 张三丰的余额=500 where name=’张三丰’意外update 表 set 郭襄的余额=1500 where name=’郭襄’ 事务的特性：ACID原子性：一个事务不可再分割，要么都执行要么都不执行一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态隔离性：一个事务的执行不受其他事务的干扰持久性：一个事务一旦提交，则会永久的改变数据库的数据. 事务的创建隐式事务：事务没有明显的开启和结束的标记比如insert、update、delete语句 delete from 表 where id =1; 但是很多时候，隐式事务不能够处理我们的问题，例如不能够同时执行这两条语句 update 表 set 张=500； update 表 set 李=1500； 显式事务：事务具有明显的开启和结束的标记前提：必须先设置自动提交功能为禁用 开启显示事务，只针对当前这一次有效： 1set autocommit=0; 步骤1：开启事务set autocommit=0;start transaction;可选的（上面的可以不写，因为写了这句就代表开启了上面那句）步骤2：编写事务中的sql语句(select insert update delete)像create drop Alter 没有事务之说；语句1;语句2;… 步骤3：结束事务commit;提交事务rollback;回滚事务，单纯的MySQL是做不到的，必须结合应用程序来进行 1.演示事务的使用步骤 开启事务 12SET autocommit=0;START TRANSACTION; 编写一组事务的语句 12UPDATE account SET balance = 1000 WHERE username='张无忌';UPDATE account SET balance = 1000 WHERE username='赵敏'; 结束事务，回滚和提交都可以 12ROLLBACK;#commit; 1SELECT * FROM account; 但你没有结束事务之前，文件的修改都保留在内存，只有进行了提交才真正的写到了硬盘 1. 事务的隔离级别 脏读 不可重复读 幻读 read uncommited √ √ √ read commited × √ √ repeatable read × × √ serializable × × × 脏读一般针对的是更新，例如update和rollback 不可重复读：也是对于更新，表示前后两次导致值不同 幻读：针对着是插入和删除，与脏读的相同点都是：没有提交， mysql中默认 第三个隔离级别 repeatable readoracle中默认第二个隔离级别 read committed查看当前的隔离级别： 1.设置为最低的隔离级别——READ-UNCOMMITTED set session transaction isolation level read uncommitted; 开启事物： set autocommit=0; 1. 脏读演示:左表还没有提交，右边就可以看到数据修改内容（将张无忌替换为了join） 数据回滚：rollback； 此时又将join变为了张无忌 这个数据也可以叫做不可重复数据，因为在这种情况下三种并发问题都可以出现： 2. 切换隔离级别为read committed;避免了脏读，但是没有避免不可重复读 set session transaction isolation level read committed; 左边已经修改了数据，为”张飞“，以为没有提交，所以右边没有改变，没有出现脏读： 不可重复读： 总结：repeatable commited可以解决脏读但是解决不了，幻读和不可重复读 3. 切换隔离级别为repeatable read set session transaction isolation level repeatable read; 解决了脏读（在未提交之前）和不可重复读（提交前后）： 解决了提交事务查询才会变为刘备： 未解决幻读：幻读就是针对插入的 左边开启一个事务，右边执行了一个事务，在左边会发生一个莫名的变化（明明看到的是三行却有四行受到了影响）： 4. 事物隔离级别为serializable;set session transaction isolation level serializable; 2. 演示事务对于delete和truncate的处理的区别delete可以成功回滚，truncate不支持回滚 1234SET autocommit=0;START TRANSACTION;DELETE FROM account;ROLLBACK; 3. 演示savepoint 的使用（有些像编程中的断点）设置了SAVEPOINT a;#设置保存点，ROLLBACK TO a;#回滚到保存点,25删除了，因为rollback所以28又回来了 1234567SET autocommit=0;START TRANSACTION;DELETE FROM account WHERE id=25;SAVEPOINT a;#设置保存点DELETE FROM account WHERE id=28;ROLLBACK TO a;#回滚到保存点SELECT * FROM account; 视图含义：虚拟表，和普通表一样使用，比如：舞蹈班和普通班级的对比，舞蹈班是临时的，但是普通班是一直存在的mysql5.1版本出现的新特性，是通过表动态生成的数据 视图的好处： 重用SQL语句； 简化了复杂的aql操作，不必知道查询细节； 保护数据，提高安全性； 创建语法的关键字 是否实际占用物理空间 使用 视图 create view 只是保存了sql逻辑 增删改查，只是一般不能增删改 表 create table 保存了数据 增删改查 创建语法的关键字 是否实际占用物理空间 使用 视图 create view 没有（只是保存了逻辑） 增删改查，一般不能增删改 表 create table 占用 增删改查 #案例：查询姓张的学生名和专业名 1234SELECT stuname,majornameFROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`WHERE s.`stuname` LIKE '张%'; 做成一个视图： 12345CREATE VIEW v1ASSELECT stuname,majornameFROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`; 此时在查询就很方便了 1SELECT * FROM v1 WHERE stuname LIKE '张%'; 一、创建视图语法：create view 视图名as查询语句; USE myemployees; 1.查询姓名中包含a字符的员工名、部门名和工种信息①创建 123456CREATE VIEW myv1ASSELECT last_name,department_name,job_titleFROM employees eJOIN departments d ON e.department_id = d.department_idJOIN jobs j ON j.job_id = e.job_id; ②使用 1SELECT * FROM myv1 WHERE last_name LIKE '%a%'; 2.查询各部门的平均工资级别①创建视图查看每个部门的平均工资，因为没有grade_level就没有生成结果 12345CREATE VIEW myv2ASSELECT AVG(salary) ag,department_idFROM employeesGROUP BY department_id; ②使用 1234SELECT myv2.`ag`,g.grade_levelFROM myv2JOIN job_grades gON myv2.`ag` BETWEEN g.`lowest_sal` AND g.`highest_sal`; 3.查询平均工资最低的部门信息，升序排列，只选择第一个11SELECT * FROM myv2 ORDER BY ag LIMIT 1; 4.查询平均工资最低的部门名和工资123CREATE VIEW myv3ASSELECT * FROM myv2 ORDER BY ag LIMIT 1; 1234SELECT d.*,m.agFROM myv3 mJOIN departments dON m.`department_id`=d.`department_id`; 二、视图的修改方式一： create or replace view 视图名as查询语句; 1SELECT * FROM myv3; 下面是修改语句，进行修改之后，再次查询，就发生了变化 12345CREATE OR REPLACE VIEW myv3ASSELECT AVG(salary),job_idFROM employeesGROUP BY job_id; 方式二： 语法：alter view 视图名as查询语句; 123ALTER VIEW myv3ASSELECT * FROM employees; 三、删除视图语法：drop view 视图名,视图名,…; 1DROP VIEW emp_v1,emp_v2,myv3; 四、查看视图DESC myv3; SHOW CREATE VIEW myv3; 案例讲解#一、创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱 12345CREATE OR REPLACE VIEW emp_v1ASSELECT last_name,salary,emailFROM employeesWHERE phone_number LIKE '011%'; #二、创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息 123456CREATE OR REPLACE VIEW emp_v2ASSELECT MAX(salary) mx_dep,department_idFROM employeesGROUP BY department_idHAVING MAX(salary)&gt;12000; 1234SELECT d.*,m.mx_depFROM departments dJOIN emp_v2 mON m.department_id = d.`department_id`; 五、视图的更新1234CREATE OR REPLACE VIEW myv1ASSELECT last_name,email,salary*12*(1+IFNULL(commission_pct,0)) \"annual salary\"FROM employees; 1234CREATE OR REPLACE VIEW myv1ASSELECT last_name,emailFROM employees; 12SELECT * FROM myv1;SELECT * FROM employees; 1.插入1INSERT INTO myv1 VALUES('张飞','zf@qq.com'); 2.修改1UPDATE myv1 SET last_name = '张无忌' WHERE last_name='张飞'; 3.删除1DELETE FROM myv1 WHERE last_name = '张无忌'; 具备以下特点的视图不允许更新①包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all 123456CREATE OR REPLACE VIEW myv1ASSELECT MAX(salary) m,department_idFROM employeesGROUP BY department_id;SELECT * FROM myv1; 更新,不可以执行，因为包含GROUP BY: 1UPDATE myv1 SET m=9000 WHERE department_id=10; ②常量视图 123CREATE OR REPLACE VIEW myv2ASSELECT 'john' NAME; 1SELECT * FROM myv2; 更新,不可以执行，因为包含常量： 1UPDATE myv2 SET NAME='lucy'; ③Select中包含子查询 123CREATE OR REPLACE VIEW myv3ASSELECT (SELECT MAX(salary) FROM employees) 最高工资; 更新SELECT * FROM myv3; UPDATE myv3 SET 最高工资=100000;不可以 ④join 123456CREATE OR REPLACE VIEW myv4ASSELECT last_name,department_nameFROM employees eJOIN departments dON e.department_id = d.department_id; 更新,不可以执行，因为包含JOIN： 123SELECT * FROM myv4;UPDATE myv4 SET last_name = '张飞' WHERE last_name='Whalen';INSERT INTO myv4 VALUES('陈真','xxxx'); ⑤from一个不能更新的视图 123CREATE OR REPLACE VIEW myv5ASSELECT * FROM myv3; 更新,不可以执行，因为包含不可以更新的视图 12SELECT * FROM myv5;UPDATE myv5 SET 最高工资=10000 WHERE department_id=60; ⑥where子句的子查询引用了from子句中的表 123456789CREATE OR REPLACE VIEW myv6ASSELECT last_name,email,salaryFROM employeesWHERE employee_id IN( SELECT manager_id FROM employees WHERE manager_id IS NOT NULL); 更新，不可以的 12SELECT * FROM myv6;UPDATE myv6 SET salary=10000 WHERE last_name = 'k_ing'; 测试题 创建book表，字段如下： bid整型，要求主键 bname字符型，要求设置唯一键，并非空 price浮点型，要求有默认值10 bttyped 类型编号，要求引用booktype表的id字段 已知booktype表（不用创建），字段如下： id,name 1234567CREATE TABLE book( bid INT PRIMARY KEY, bname VARCHAR(20)UNIQUE NOT NULL price FLOAT DEFAULT 10, btypedId INT, FOREIGN KEY(btypeid) REFERENCES bookType(id)); 2.开启事物向表中插入1行数据，并结束 1234set autocommit=0；insert into book(bid,bname,price,btypeId)values(1,'小李飞刀'，100,1);rollback; 3.创建视图，实现查询价格在90-120之间的书名和价格 123456create view myv1as select bname,namefrom book bjoin bookType t on b.typeid=t.idwhere price&gt;100; 4.修改视图，实现查询价格在90-120之间的书名和价格 12345create or replace view myv1asselect bname,pricefrom bookwhere price between 90 and 120; 5.删除刚才建的视图 1drop view myv1； $$ —- \\mathcal{End} —- $$","link":"/2020/06/06/数据库/5.常见约束&TCL事务控制语言/"},{"title":"4.变量&存储过程","text":"最近更新： 2020-6-10 upds。 1. 变量系统变量： 全局变量 会话变量 自定义变量： 用户变量 局部变量 一、系统变量说明：变量由系统定义，不是用户定义，属于服务器层面注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别 使用步骤：1、查看所有系统变量 1show global|【session】variables; 1set @@global|【session】系统变量名=值; 2、查看满足条件的部分系统变量 1show global|【session】 variables like &apos;%char%&apos;; 3、查看指定的系统变量的值 1select @@global|【session】系统变量名; 4、为某个系统变量赋值方式一： 1set global|【session】系统变量名=值; 方式二： 1.全局变量作用域：针对于所有会话（连接）有效，但不能跨重启 ①查看所有全局变量 1SHOW GLOBAL VARIABLES; ②查看满足条件的部分系统变量 1SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;; ③查看指定的系统变量的值 1SELECT @@global.autocommit; ④为某个系统变量赋值 12SET @@global.autocommit=0;SET GLOBAL autocommit=0; 2. 会话变量作用域：针对于当前会话（连接）有效 ①查看所有会话变量 1SHOW SESSION VARIABLES; #②查看满足条件的部分会话变量 1SHOW SESSION VARIABLES LIKE &apos;%char%&apos;; #③查看指定的会话变量的值 12SELECT @@autocommit;SELECT @@session.tx_isolation; #④为某个会话变量赋值 12SET @@session.tx_isolation=&apos;read-uncommitted&apos;;SET SESSION tx_isolation=&apos;read-committed&apos;; 二、自定义变量说明：变量由用户自定义，而不是系统提供的使用步骤：1、声明2、赋值3、使用（查看、比较、运算等） 1. 用户变量作用域：针对于当前会话（连接）有效，作用域同于会话变量 赋值操作符：=或:=①声明并初始化,三种方式： 123SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值; ②赋值（更新变量的值）和上面一样，所以既可以当声明又可以当赋值方式一： 123SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值; 方式二： 12SELECT 字段 INTO @变量名 FROM 表; ③使用（查看变量的值） 1SELECT @变量名; 2.局部变量作用域：仅仅在定义它的begin end块中有效应用在 begin end中的第一句话 ①声明 12DECLARE 变量名 类型;DECLARE 变量名 类型 【DEFAULT 值】; ②赋值（更新变量的值） 方式一： 123SET 局部变量名=值;SET 局部变量名:=值;SELECT 局部变量名:=值; 方式二： 12SELECT 字段 INTO 具备变量名FROM 表; ③使用（查看变量的值） 1SELECT 局部变量名; 案例：声明两个变量，求和并打印 用户变量 1234SET @m=1;SET @n=1;SET @sum=@m+@n;SELECT @sum; 局部变量 12345DECLARE m INT DEFAULT 1;DECLARE n INT DEFAULT 1;DECLARE SUM INT;SET SUM=m+n;SELECT SUM; 用户变量和局部变量的对比: 作用域 作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 必须加@符号，不用限定类型 局部变量 BEGIN END中 只能在BEGIN END中，且为第一句话 一般不用加@符号，需要限定类型 2.存储过程存储过程和函数：类似于java中的方法好处：1、提高代码的重用性2、简化操作 存储过程含义：一组预先编译好的SQL语句的集合，理解成批处理语句1、提高代码的重用性2、简化操作3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率 一、创建语法1234CREATE PROCEDURE 存储过程名(参数列表)BEGIN 存储过程体（一组合法的SQL语句）END 注意：1、参数列表包含三部分参数模式 参数名 参数类型举例：in stuname varchar(20) 参数模式：in：该参数可以作为输入，也就是该参数需要调用方传入值out：该参数可以作为输出，也就是该参数可以作为返回值inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值 2、如果存储过程体仅仅只有一句话，begin end可以省略存储过程体中的每条sql语句的结尾要求必须加分号。存储过程的结尾可以使用 delimiter 重新设置语法：delimiter 结束标记案例： 1delimiter $ 二、调用语法1CALL 存储过程名(实参列表); 1.空参列表案例：插入到admin表中五条记录 SELECT * FROM admin; 123456DELIMITER $CREATE PROCEDURE myp1()BEGIN INSERT INTO admin(username,`password`) VALUES('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');END $ 运行上面的结束之后就会在存储过程的文件夹下存在myp1 调用（就和调用函数是一样的）： 1CALL myp1()$ 2.创建带in模式参数的存储过程案例1：创建存储过程实现 根据女神名，查询对应的男神信息 1234567CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))BEGIN SELECT bo.* FROM boys bo RIGHT JOIN beauty b ON bo.id = b.boyfriend_id WHERE b.name=beautyName;END $ 调用： 1CALL myp2('小昭')$ 案例2 ：创建存储过程实现，用户是否登录成功 12345678910CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))BEGIN DECLARE result VARCHAR(20) DEFAULT '';#声明并初始化 SELECT COUNT(*) INTO result#赋值 FROM admin WHERE admin.username = username AND admin.password = PASSWORD; SELECT IF(result&gt;0,'成功','失败');#使用END $ 调用 1CALL myp3('张飞','8888')$ 3. 创建out 模式参数的存储过程案例1：根据输入的女神名，返回对应的男神名 123456789CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))BEGIN SELECT bo.boyname INTO boyname FROM boys bo RIGHT JOIN beauty b ON b.boyfriend_id = bo.id WHERE b.name=beautyName ; END $ 案例2：根据输入的女神名，返回对应的男神名和魅力值 12345678CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) BEGIN SELECT boys.boyname ,boys.usercp INTO boyname,usercp FROM boys RIGHT JOIN beauty b ON b.boyfriend_id = boys.id WHERE b.name=beautyName ;END $ 调用 1CALL myp7('小昭',@name,@cp)$ 1SELECT @name,@cp$ 4.创建带inout模式参数的存储过程案例1：传入a和b两个值，最终a和b都翻倍并返回 12345CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)BEGIN SET a=a*2; SET b=b*2;END $ 调用 123SET @m=10$SET @n=20$CALL myp8(@m,@n)$ SELECT @m,@n$ 案例讲解：一、创建存储过程实现传入用户名和密码，插入到admin表中12345CREATE PROCEDURE test_pro1(IN username VARCHAR(20),IN loginPwd VARCHAR(20))BEGIN INSERT INTO admin(admin.username,PASSWORD) VALUES(username,loginpwd);END $ 二、创建存储过程实现传入女神编号，返回女神名称和女神电话12345678CREATE PROCEDURE test_pro2(IN id INT,OUT NAME VARCHAR(20),OUT phone VARCHAR(20))BEGIN SELECT b.name ,b.phone INTO NAME,phone FROM beauty b WHERE b.id = id;END $ 三、创建存储存储过程或函数实现传入两个女神生日，返回大小1234CREATE PROCEDURE test_pro3(IN birth1 DATETIME,IN birth2 DATETIME,OUT result INT)BEGIN SELECT DATEDIFF(birth1,birth2) INTO result;END $ 四、创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回123456DELIMITER //CREATE PROCEDURE test_pro4(IN mydate DATETIME,OUT strDate VARCHAR(50))BEGIN SELECT DATE_FORMAT(mydate,'%y年%m月%d日') INTO strDate;END // 123CALL test_pro4(NOW(),@str)SELECT @str $// 五、创建存储过程或函数实现传入女神名称，返回：女神 and 男神 格式的字符串如 传入 ：小昭返回： 小昭 AND 张无忌 12345678DROP PROCEDURE test_pro5 $CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))BEGIN SELECT CONCAT(beautyName,' and ',IFNULL(boyName,'null')) INTO str FROM boys bo RIGHT JOIN beauty b ON b.boyfriend_id = bo.id WHERE b.name=beautyName;END $ ​ 12CALL test_pro5('柳岩',@str)$SELECT @str $ 六、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录12345DROP PROCEDURE test_pro6$CREATE PROCEDURE test_pro6(IN startIndex INT,IN size INT)BEGIN SELECT * FROM beauty LIMIT startIndex,size;END $ 1CALL test_pro6(3,5)$ 三、删除存储过程语法：drop procedure 存储过程名 1DROP PROCEDURE p1; 不可以：DROP PROCEDURE p2,p3;#× 四、查看存储过程的信息DESC myp1;× 1SHOW CREATE PROCEDURE myp1; 注意：没有办法修改里面的逻辑语句，所以只可以删除重新建立 3. 函数含义：一组预先编译好的SQL语句的集合，理解成批处理语句1、提高代码的重用性2、简化操作3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率 区别： 存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新函数：有且仅有1 个返回，适合做处理数据后返回一个结果 一、创建语法1234CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型BEGIN 函数体END 注意：1.参数列表 包含两部分：参数名 参数类型 2.函数体：肯定会有return语句，如果 没有会报错如果return语句没有放在函数体的最后也不报错，但不建议 return 值;3.函数体中仅有一句话，则可以省略begin end4.使用 delimiter语句设置结束标记 二、调用语法SELECT 函数名(参数列表) 1.无参有返回案例：返回公司的员工个数 1234567CREATE FUNCTION myf1() RETURNS INTBEGINDECLARE c INT DEFAULT 0;#定义局部变量SELECT COUNT(*) INTO c#赋值FROM employees;RETURN c;END $ 1SELECT myf1()$ 2.有参有返回案例1：根据员工名，返回它的工资 12345678CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLEBEGIN SET @sal=0;#定义用户变量 SELECT salary INTO @sal #赋值 FROM employees WHERE last_name = empName;RETURN @sal;END $ 1SELECT myf2('k_ing') $ 案例2：根据部门名，返回该部门的平均工资 123456789CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLEBEGIN DECLARE sal DOUBLE ; SELECT AVG(salary) INTO sal FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE d.department_name=deptName; RETURN sal;END $ 1SELECT myf3('IT')$ 三、查看函数1SHOW CREATE FUNCTION myf3; 四、删除函数1DROP FUNCTION myf3; 案例一、创建函数，实现传入两个float，返回二者之和 123456CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOATBEGIN DECLARE SUM FLOAT DEFAULT 0; SET SUM=num1+num2; RETURN SUM;END $ 1SELECT test_fun1(1,2)$ 4.流程控制结构顺序、分支、循环 一、分支结构1.if函数语法：if(条件,值1，值2)功能：实现双分支应用在begin end中或外面 2.case结构语法： 情况1：类似于switch123456case 变量或表达式when 值1 then 语句1;when 值2 then 语句2;...else 语句n;end 情况2：类似于java中的多重if语句，一般用于实现区间判断123456case when 条件1 then 语句1;when 条件2 then 语句2;...else 语句n;end 特点： 可以作为表达式，嵌套在其他语句中，可以放在任何地方，应用在begin end 中或外面 可以作为独立的语句使用，但只能放在BEGIN END中 如果when 中的值满足或者条件成立，则执行对应的THEN后面的语句，并且结束case，如果不满足则执行else的语句和值 ELSE可以省略，当when都不满足，返回null 3.if结构语法：if 条件1 then 语句1;elseif 条件2 then 语句2;….else 语句n;end if;功能：类似于多重if 只能应用在begin end 中 案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D 123456789CREATE FUNCTION test_if(score FLOAT) RETURNS CHARBEGIN DECLARE ch CHAR DEFAULT 'A'; IF score&gt;90 THEN SET ch='A'; ELSEIF score&gt;80 THEN SET ch='B'; ELSEIF score&gt;60 THEN SET ch='C'; ELSET ch='D'; RETURN ch;END $ 1SELECT test_if(87)$ 案例2：创建存储过程，如果工资&lt;2000,则删除，如果5000&gt;工资&gt;2000,则涨工资1000，否则涨工资500 1234567CREATE PROCEDURE test_if_pro(IN sal DOUBLE)BEGIN IF sal&lt;2000 THEN DELETE FROM employees WHERE employees.salary=sal; ELSEIF sal&gt;=2000 AND sal&lt;5000 THEN UPDATE employees SET salary=salary+1000 WHERE employees.`salary`=sal; ELSE UPDATE employees SET salary=salary+500 WHERE employees.`salary`=sal; END IF;END $ 1CALL test_if_pro(2100)$ 案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D 123456789101112CREATE FUNCTION test_case(score FLOAT) RETURNS CHARBEGIN DECLARE ch CHAR DEFAULT 'A';CASE WHEN score&gt;90 THEN SET ch='A';WHEN score&gt;80 THEN SET ch='B';WHEN score&gt;60 THEN SET ch='C';ELSE SET ch='D';END CASE;RETURN ch;END $ 1SELECT test_case(56)$ 二、循环结构分类：we、loop、repeat 循环控制： iterate类似于 continue，继续，结束本次循环，继续下一次leave 类似于 break，跳出，结束当前所在的循环 1.while语法： 【标签:】while 循环条件 do 循环体;end while【 标签】; 联想： 12345while(循环条件){ 循环体;} 2.loop语法：【标签:】loop 循环体;end loop 【标签】; 可以用来模拟简单的死循环 3.repeat语法：【标签：】repeat 循环体;until 结束循环的条件end repeat 【标签】; 1.没有添加循环控制语句案例：批量插入，根据次数插入到admin表中多条记录 1DROP PROCEDURE pro_while1$ 12345678CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; WHILE i&lt;=insertCount DO INSERT INTO admin(username,`password`) VALUES(CONCAT('Rose',i),'666'); SET i=i+1; END WHILE;END $ 1CALL pro_while1(100)$ 语法： 12345678int i=1;while(i&lt;=ertcount){ //插入 i++;} 2.添加leave语句案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止TRUNCATE TABLE admin$DROP PROCEDURE test_while1$ 12345678910CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; a:WHILE i&lt;=insertCount DO INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); IF i&gt;=20 THEN LEAVE a; END IF; SET i=i+1; END WHILE a;END $ CALL test_while1(100)$ 3.添加iterate语句案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次 12345678910111213TRUNCATE TABLE admin$DROP PROCEDURE test_while1$CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 0; a:WHILE i&lt;=insertCount DO SET i=i+1; IF MOD(i,2)!=0 THEN ITERATE a; END IF; INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); END WHILE a;END $ CALL test_while1(100)$ 1234567891011int i=0;while(insertCount){ i++; if(i%2==0){ continue; } 插入}已知表stringcontent其中字段：id 自增长content varchar(20) 案例：已知表stringcontent其中字段：id 自增长content varchar(20) 向该表插入指定个数的，随机的字符串 123456DROP TABLE IF EXISTS stringcontent;CREATE TABLE stringcontent( id INT PRIMARY KEY AUTO_INCREMENT, content VARCHAR(20));DELIMITER $ 12345678910111213CREATE PROCEDURE test_randstr_insert(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; DECLARE str VARCHAR(26) DEFAULT 'abcdefghijklmnopqrstuvwxyz'; DECLARE startIndex INT;#代表初始索引 DECLARE len INT;#代表截取的字符长度 WHILE i&lt;=insertcount DO SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26 SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1） INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len)); SET i=i+1; END WHILE;END $ 1CALL test_randstr_insert(10)$ $$ —- \\mathcal{End} —- $$","link":"/2020/06/10/数据库/4.变量&存储过程/"},{"title":"python面向对象","text":"最近更新： 2020-9-21 类定义1234class ClassName: &lt;statement-1&gt; . &lt;statement-N&gt; 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象类对象支持两种操作：属性引用和实例化。 属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。 类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样: 1234567891011121314#!/usr/bin/python3 class MyClass: \"\"\"一个简单的类实例\"\"\" i = 12345 def f(self): return 'hello world' # 实例化类x = MyClass() # 访问类的属性和方法print(\"MyClass 类的属性 i 为：\", x.i)print(\"MyClass 类的方法 f 输出为：\", x.f()) 执行以上程序输出结果为： 12MyClass 类的属性 i 为： 12345MyClass 类的方法 f 输出为： hello world 类有一个名为 init() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样： 12def __init__(self): self.data = [] 类定义了 init() 方法，类的实例化操作会自动调用 init() 方法。如下实例化类 MyClass，对应的 init() 方法就会被调用: 1x = MyClass() 当然， init() 方法可以有参数，参数通过 init() 传递到类的实例化操作上。例如: 12345678#!/usr/bin/python3 class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpartx = Complex(3.0, -4.5)print(x.r, x.i) # 输出结果：3.0 -4.5 self代表类的实例，而非类类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 12345class Test: def prt(self): print(self) print(self.__class__) t = Test() t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的: 1234567class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test()t.prt() self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的: class Test: def prt(runoob): print(runoob) print(runoob.class) t = Test() t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 类的方法在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。 实例(Python 3.0+)1234567891011121314151617181920#!/usr/bin/python3 #类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) # 实例化类p = people('runoob',10,30)p.speak() 执行以上程序输出结果为： 1runoob 说: 我 10 岁。 继承Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示: 123456class DerivedClassName(BaseClassName1): &lt;statement-1&gt; . . . &lt;statement-N&gt; BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: 1class DerivedClassName(modname.BaseClassName): 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python3 #类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) s = student('ken',10,60,3)s.speak() 执行以上程序输出结果为： 1ken 说: 我 10 岁了，我在读 3 年级 多继承Python同样有限的支持多继承形式。多继承的类定义形如下例: 123456class DerivedClassName(Base1, Base2, Base3): &lt;statement-1&gt; . . . &lt;statement-N&gt; 需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python3 #类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic)) #多重继承class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(\"Tim\",25,80,4,\"Python\")test.speak() #方法名同，默认调用的是在括号中排前地父类的方法 执行以上程序输出结果为： 1我叫 Tim，我是一个演说家，我演讲的主题是 Python 方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： 12345678910111213#!/usr/bin/python3 class Parent: # 定义父类 def myMethod(self): print ('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print ('调用子类方法') c = Child() # 子类实例c.myMethod() # 子类调用重写方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 super() 函数是用于调用父类(超类)的一个方法。 执行以上程序输出结果为： 12调用子类方法调用父类方法 类属性与方法类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的方法在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。 类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 实例类的私有属性实例如下： 12345678910111213141516#!/usr/bin/python3 class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter()counter.count()#1counter.count()#2print (counter.publicCount)#2print (counter.__secretCount) # 报错，实例不能访问私有变量 执行以上程序输出结果为： 1234567122Traceback (most recent call last): File \"test.py\", line 16, in &lt;module&gt; print (counter.__secretCount) # 报错，实例不能访问私有变量AttributeError: 'JustCounter' object has no attribute '__secretCount' 类的私有方法实例如下： 12345678910111213141516171819202122#!/usr/bin/python3 class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print('name : ', self.name) print('url : ', self.__url) def __foo(self): # 私有方法 print('这是私有方法') def foo(self): # 公共方法 print('这是公共方法') self.__foo() x = Site('菜鸟教程', 'www.runoob.com')x.who() # 正常输出x.foo() # 正常输出x.__foo() # 报错 以上实例执行结果： 类的专有方法： init : 构造函数，在生成对象时调用 del : 析构函数，释放对象时使用 repr : 打印，转换 setitem : 按照索引赋值 getitem: 按照索引获取值 len: 获得长度 cmp: 比较运算 call: 函数调用 add: 加运算 sub: 减运算 mul: 乘运算 truediv: 除运算 mod: 求余运算 pow: 乘方 运算符重载Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下： 12345678910111213141516#!/usr/bin/python3 class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2) $$ —- \\mathcal{End} —- $$","link":"/2020/07/12/python/python面向对象/"},{"title":"linux基础篇","text":"第一章 实操类 实用指令1.1文件目录类pwd：查看当前所在文件ls：查看当前所在文件夹下内容 ls -a：显示指定目录下所有子目录与文件，包含隐藏文件。 ls -l：以列表方式显示文件的详细信息。 ls -h：配合-l以人性化方式显示文件大小。 cd [目录名]：切换文件夹touch [文件名]：如果文件不存在，新建文件 mkdir [目录名]：创建目录 rmdir[目录名]：删除空目录 rm[文件名]：删除文件名 使用rm要小心因为删除后文件不可以恢复 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归的删除目录下的文件的内容，删除文件夹时候，必须带此参数 cp [文件名] 或 [目录名] 常用选型 ​ -r:递归复制整个文件夹 案例1：将/home/aaa.txt 拷贝到 /home/bbb目录下： 案例2：将/home/test 整个目录copy到 /home/zwj/ clear :清屏cat:以只读的格式打开文件more:分屏显示文件内容，每次只显示一页内容 less:和上面类似，但对于大型文件具有较高的效率 head:用于显示文件开头部分内容 tail:用于输出文件尾部的内容 echo:输出内容到控制台 ln:软连接，类似于windows的快捷方式 1.2搜索查找类find：从指定的目录下递归的查找各个子目录，将满足条件的文件或者目录显示在终端上 选项 功能 -name 按照指定文件名查找文件 -user 查找属于指定用户的所有文件 -size 按照指定文件大小查找文件 案例1：按照文件名，根据名称查找/home目录下的hello.txt 案例2：按照拥有者，查找/opt目录下的，用户名称为nodody的文件 案例3：查找Linux系统下大于20M的文件 案例4：查找 / 目录下所有的.txt的文件 locate:快速定位文件路径 特别说明：由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库 案例：定位hello.txt文件的所在目录 grep：过滤查找管道符，”|”,表示将前一个命令的处理结果输出传递给后面的命令处理 -n 显示匹配行和行号 -i 忽略字母大小写 案例1：请在hello.txt文件中，查找“yes“所在行，并且显示行号 1.3压缩和解压类以后补上，看尚硅谷老师的课 1.4 Vim&amp;查看文章 查看的常用命令空格键：显示下一屏Enter键：一次滚动一行b：回滚一屏f：前滚一屏q：退出Tab:自动补全（若有歧义在按一下,提示可能有的目录）ctrl+c:退出选择，重新回到终端 通配符的使用*:代表任意一个字符?:代表任意一个字符，至少一个[]：表示可以匹配字符组的任意一个[]：匹配a,b,c中的任意一个[a-f]：匹配a到f中的任意一个 例子：LS 5.txt （也可以不加后缀名）； LS \\3* ctrl+s：保存文件（文件如多有一个*说明这个文件没有被保存）man是manual的缩写，是linux提供的手册 第二章 实操类 进程管理ps:查看进程的使用指令 一般使用的参数是 ps -aux PID 进程识别号 TTY 终端机号 TIME 此进程所消耗的CPU时间 CMD 正在执行的命令或者进程名 ps -a：显示当前终端的所有进程信息 ps -u:以用户的格式显示进行信息 ps -x:显示后台进程运行的参数 ps -ef:以全格式显示当前的所有进程 kill:终止进程kill [进程号]，killall，也可以使用通配符 -9：表示强迫进程立即停止 案例1:踢掉某个非法登录用户 案例2：终止远程登录服务sshd，在适当时候再次重启sshd服务 案例3：终止多个gedit编辑器 killall gedit 案例4：强制杀掉一个终端 pstree：查看进程树-p:显示进程PID -u：显示进程的所有属性 Service:服务管理服务本质就是进程，只是运行在后台，通常会监听某个端口，等待其他程序请求，比如（mysql，sshd 防火墙等），因此我们又称为守护线程，是Linux中非常重要的知识点 在centos7.0以后，不在使用service，而是systemctl 使用案例：查看当前防火墙状态，关闭防火墙和重启防火墙 /etc/init.d/服务名称 服务的运行级别： chkconfig为每个服务的各个运行级别设置自启动/关闭 top动态监控进程top与ps命令很相似，都是用来显示正在执行的进程，top的不同在于可以更新正在运行的进程 -d 指定top命令每隔几秒钟更新，默认是3秒 -i 使top不显示闲置和僵死的进程 -p 通过指定监控进程ID来仅仅监控某个进程 -u 后加用户名即可查看指定的用户 监控特定用户： 输入top后，回车查看进程，然后输入“k”回车，在输入要结束的进程ID号 netstat查看系统网络情况 -an 按照一定排列顺序输出 -p 显示哪个进程在调用 查看系统所有的网络服务 查看服务名为sshd的服务信息 之前查询端口是否被占用一直搞不明白，问了好多人，终于搞懂了，现在总结下： 1.netstat -anp |grep 端口号 如下，我以3306为例，netstat -anp |grep 3306（此处备注下，我是以普通用户操作，故加上了sudo，如果是以root用户操作，不用加sudo即可查看），如下图1： ​ 图1 图1中主要看监控状态为LISTEN表示已经被占用，最后一列显示被服务mysqld占用，查看具体端口号，只要有如图这一行就表示被占用了。 2.netstat -nultp（此处不用加端口号） 该命令是查看当前所有已经使用的端口情况，如图2： 软连接和硬链接软连接：（符号连接）等同于Windows的快捷方式 创建一个软连接注意创建的语法：ln -s是必须的，然后后面跟一个目标文件夹，最后是一个当前目录的软连接名。 12345678910111213141516171819202122[root@server6 ~]# ln -s test_chk/ test_chk_ln[root@server6 ~]# ll总用量 84-rw-------. 1 root root 1257 6月 16 01:17 anaconda-ks.cfgdrwxr-xr-x. 25 root root 4096 11月 1 10:28 azkabanJob-rw-r--r--. 1 root root 67322 11月 4 10:24 azkabanJob.zipdrwxr-xr-x. 4 root root 37 7月 13 11:01 hadoop_temp-rw-r--r--. 1 root root 54 7月 4 14:11 HelloLinux.txtdrwxr-xr-x. 2 root root 22 11月 4 10:41 test_chklrwxrwxrwx. 1 root root 9 11月 4 10:42 test_chk_ln -&gt; test_chk/-rw-r--r--. 1 root root 67 10月 8 15:52 zookeeper.out[root@server6 ~]# cd test_chk_ln/[root@server6 test_chk_ln]# ll总用量 4-rw-r--r--. 1 root root 12 11月 4 10:41 test.txt[root@server6 test_chk_ln]# cat test.txt hello spark[root@server6 test_chk_ln]# ll总用量 4-rw-r--r--. 1 root root 12 11月 4 10:41 test.txt[root@server6 test_chk_ln]# cat test.txt hello spark 可以看到软连接文件前面是l其他都是-，-代表文本文件，d代表是一个文件夹，而l就是连接文件 硬连接：ln 源文件名 连接文件名 硬链接：就好像是copy，但是在linux里面就只有一份，这个文件好像多了几条命， $$ —- \\mathcal{End} —- $$","link":"/2019/05/14/命令行与配置/linux 笔记/"},{"title":"leetcode 1-50","text":"1. 两数之和Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 这个是没有用到字典的代码，虽然实现了上述功能但是，时间花费很多。 12345678910&gt;class Solution:&gt;def twoSum(self, nums,target):&gt;for i in nums:&gt; j=target-i&gt; start_index = nums.index(i)&gt; next_index = start_index+1&gt; temp_nums = nums[next_index:] //将从next_index到最后最后这些元素新建一个Array&gt; if j in temp_nums: //判断一下j是否在temp_nums这个数组中&gt; return(nums.index(i),next_index+temp_nums.index(j))&gt; 1234567891011121314151617181920212223class Solution { public int[] twoSum(int[] nums, int target) { if (nums == null || nums.length&lt;2){ return new int[]{-1,-1}; } int[] res=new int []{-1,-1}; //为了存最后的访问结果 HashMap&lt;Integer,Integer &gt; map = new HashMap&lt;&gt;();//定义一个HashMap for(int i =0;i&lt;nums.length;i++){ //遍历这个数组 if (map.containsKey(target-nums[i])){ res[0]= map.get(target-nums[i]); res[1]=i; break; } map.put(nums[i],i); //HashMap存对应的每个值，和index } return res; } public static void main(String[] args){ } } 这段代码主要用到了hashmap的算法，大大提高了效率，但是暂时还不会 9. 回文数题目摘要判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 思路一些一定不为回文数的数：1.负数2.大于0，但末位为0的数（x&gt; 0 &amp;&amp; x % 10 == 0）如果是上面这些情况则直接返回false。 将整数的每一位存入数组中，arr[i]代表整数的倒数i+1位。 然后判断arr[i]是否和arr[num -1 -i]位是否相等，如果相等则判断下一位；否则返回false当i&gt; num-i-1时如果还没返回则代表所有字符的是相对称的，也就是回文数，返回true 下面是python的代码：12345678910111213141516class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" a=abs(x) sum=0 while(a!=0): p=x%10 sum=sum*10+p a=a//10 if x&gt;=0 and x==sum: return True else: return False 下面是高级版python代码：希望以后再回来看将它弄懂1234class Solution: def isPalindrome(self, x: int) -&gt; bool: r = list(map(lambda i: int(10**-i * x % 10), range(int(math.log10(x)), -1, -1))) if x &gt; 0 else [0, x] return r == r[::-1] 下面是java的代码：简单暴力型的主要是用到java自带的函数： 1234567///简单粗暴，看看就行class Solution { public boolean isPalindrome(int x) { String reversedStr = (new StringBuilder(x + \"\")).reverse().toString(); return (x + \"\").equals(reversedStr); }} 解法二：进阶解法—数学解法通过取整和取余操作获取整数中对应的数字进行比较。 举个例子：1221 这个数字。具体做法如下： 通过计算 1221 / 1000， 得首位1 通过计算 1221 % 10， 可得末位 1 进行比较 再将 22 取出来继续比较 1234567891011121314151617class Solution { public boolean isPalindrome(int x) { //定义一个布尔类型的方法 //边界判断 if (x &lt; 0) return false; int div = 1; // while (x / div &gt;= 10) div *= 10; while (x &gt; 0) { int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; } return true; }} 解法三：进阶解法—巧妙解法直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。 所以这个解法的操作就是 取出后半段数字进行翻转。 这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。 具体做法如下： 每次进行取余操作 （ %10），取出最低的数字：y = x % 10 将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y 每取一个最低位数字，x 都要自除以 10 判断 x 是不是小于revertNum ，当它小于的时候，说明数字已经对半或者过半了 最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数 字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。 123456789101112class Solution { public boolean isPalindrome(int x) { //思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; int revertedNumber = 0; while (x &gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; }} 14. 最长公共前缀难度 easy 题目名称 题目摘要编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出:&quot;&quot;解释: 输入不存在公共前缀。 思路首先判断字符串是否为空，如果是直接输出&quot;&quot;之后建立两个for循环，第一层循环是遍历第一个字符串，第二个循环是从第二个字符串开始和第一个字符串进行比较，这里有一些反常，就是不满足条件就退出。这个条件是i大于字符串的长度，或者就是遇到不相等的了，返回这个前缀，当然如果是一个空字符串，就返回&quot;&quot;123456789class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return\"\" for i in range(len(strs[0])): for string in strs[1:]: #从列表中第一个位置与第0的位置比较 if i&gt;=len(string) or string[i] != strs[0][i] : #就是遍历的i大于单词的长度 return strs[0][:i] return strs[0] #如果是一个[\"\"],这种情况下返回第一个字符 下面是高级一些的python代码： 思路2我先设置一个空的字符串，1234567891011121314151617class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: result =\"\" i=0 while True: try: sets=set(string[i]for string in strs)#因为set是集合的概念，遍历这个列表的每一个字符串的第i位，输出的都是不同的值，如果相同就输出一个， if len(sets)==1: #如果对应位置不是同一个字符，那么就不会是1 result+=sets.pop()# pop是出栈的意思，后进后出（当然也只有一个元素）弹出加在result后面 i+=1#在去检查下一个字符 else: break except Exception as e: # break return result $$ —- \\mathcal{End} —- $$","link":"/2019/07/12/数据结构与算法/leetcode1-50/"},{"title":"从CNN到UNet","text":"1 FCN改变了什么？对于一般的分类CNN网络，如VGG和Resnet，都会在网络的最后加入一些全连接层，经过softmax后就可以获得类别概率信息。但是这个概率信息是1维的，即只能标识整个图片的类别，不能标识每个像素点的类别，所以这种全连接方法不适用于图像分割。 图3 全连接层 而FCN提出可以把后面几个全连接都换成卷积，这样就可以获得一张2维的feature map，后接softmax获得每个像素点的分类信息，从而解决了分割问题，如图4。 图4 2 FCN结构整个FCN网络基本原理如图5（只是原理示意图）： image经过多个conv和+一个max pooling变为pool1 feature，宽高变为1/2 pool1 feature再经过多个conv+一个max pooling变为pool2 feature，宽高变为1/4 pool2 feature再经过多个conv+一个max pooling变为pool3 feature，宽高变为1/8 …… 直到pool5 feature，宽高变为1/32。 图5 FCN网络结构示意图 那么： 对于FCN-32s，直接对pool5 feature进行32倍上采样获得32x upsampled feature，再对32x upsampled feature每个点做softmax prediction获得32x upsampled feature prediction（即分割图）。 对于FCN-16s，首先对pool5 feature进行2倍上采样获得2x upsampled feature，再把pool4 feature和2x upsampled feature逐点相加，然后对相加的feature进行16倍上采样，并softmax prediction，获得16x upsampled feature prediction。 对于FCN-8s，首先进行pool4+2x upsampled feature逐点相加，然后又进行pool3+2x upsampled逐点相加，即进行更多次特征融合。具体过程与16s类似，不再赘述。 作者在原文种给出3种网络结果对比，明显可以看出效果：FCN-32s &lt; FCN-16s &lt; FCN-8s，即使用多层feature融合有利于提高分割准确性。 图5.1 3 什么是上采样？说了半天，到底什么是上采样？ 实际上，上采样（upsampling）一般包括2种方式： Resize，如双线性插值直接缩放，类似于图像缩放（这种方法在原文中提到） Deconvolution，也叫Transposed Convolution 什么是Resize就不多说了，这里解释一下Deconvolution。 对于一般卷积，输入蓝色4x4矩阵，卷积核大小3x3。当设置卷积参数pad=0，stride=1时，卷积输出绿色2x2矩阵，如图6。 图6 Convolution forward示意图 而对于反卷积，相当于把普通卷积反过来，输入蓝色2x2矩阵（周围填0变成6x6），卷积核大小还是3x3。当设置反卷积参数pad=0，stride=1时输出绿色4x4矩阵，如图7，这相当于完全将图4倒过来（其他更多卷积示意图点这里）。 图7 Deconvolution forward示意图 传统的网络是subsampling的，对应的输出尺寸会降低；upsampling的意义在于将小尺寸的高维度feature map恢复回去，以便做pixelwise prediction，获得每个点的分类信息。 图8 Subsampling vs Upsampling 上采样在FCN网络中的作用如图8，明显可以看到经过上采样后恢复了较大的pixelwise feature map（其中最后一个层21-dim是因为PACSAL数据集有20个类别+Background）。这其实相当于一个Encode-Decode的过程。 $$ —- \\mathcal{End} —- $$","link":"/2021/01/12/深度学习/从CNN到UNet/"},{"title":"双向链表java实现","text":"一 双向链表简介双向链表的定义是，一个节点有两个方向，分别储存当前节点的前驱节点，和后续节点；双向链表的删除只需要指定前驱节点，或者后续节点就可以进行删除操作；但是缺点也很明显每次添加节点时都需要2个指向，额外增加了内存空间消耗； 二 双向链表的实现3.1 定义链表节点 定义data存储数据，知识追寻者使用的时int类型，读者可以改为object类型； 定义前驱节点previous 定义后续节点next 1234567891011121314/** * @Author lsc * &lt;p&gt; 双向链表节点 &lt;/p&gt; */public class DoubleNode { //数据 private Integer data; //后续节点节点 private DoubleNode next; //前驱节点 private DoubleNode previous; // 省略set get} 3.2 插入头节点思路如下: 将新节点的前驱节点指向nul 新节点的后续节点指向表头 将表头的前驱节点指向新节点 1234567891011121314151617181920212223242526272829303132333435363738394041public class DoubleList { private DoubleNode head; public void addFirst(int data){ // 创建新节点 DoubleNode newNode = new DoubleNode(); // 为新节点添加数据 newNode.setData(data); // 如果表头为空直接将新节点作为头 if (head==null){ head = newNode; }else { //将新节点的前驱节点指向null(声明的时候本来就是null) //新节点的后续节点指向表头 newNode.setNext(head); // 将表头的前驱节点指向新节点 head.setPrevious(newNode); // head重新赋值 head = newNode; } } /* * * @Author lsc * &lt;p&gt;顺序打印链表 思路：从链表的头遍历到链表的尾巴 * &lt;/p&gt; * @Param [] * @Return void */ public void displayNext(){ // 将表头作为当前节点 DoubleNode currentNode = head; // 遍历链表 while (currentNode!=null){ // 打印数据 System.out.println(currentNode.getData()); // 将下一个节点作为当前节点 currentNode = currentNode.getNext(); } }} 测试代码如下，往前插入数据，打印出来就是倒序 1234567public static void main(String[] args) { DoubleList doubleList = new DoubleList(); for (int i = 0; i &lt;5 ; i++) { doubleList.addFirst(i); } doubleList.displayNext(); } 结果 1234543210 3.3 插入尾节点思路如下 表尾的后续节点指向新节点 新节点的前驱节点指向表尾 新节点的后续节点指向null 123456789101112131415161718192021222324252627/* * * @Author lsc * &lt;p&gt; 表尾插入节点 * &lt;/p&gt; * @Param [data] * @Return void */ public void addLast(int data){ // 创建新节点 DoubleNode newNode = new DoubleNode(); // 为新节点添加数据 newNode.setData(data); // 如果表头为空直接将新节点作为头 if (head==null){ head = newNode; }else { DoubleNode currentNode = head; //寻找尾节点 while (currentNode.getNext()!=null){ currentNode = currentNode.getNext(); } //表尾的后续节点指向新节点 currentNode.setNext(newNode); //新节点的前驱节点指向表尾 newNode.setPrevious(currentNode); } } 测试代码如下，往表为插入数据，也就是顺序打印 12345678public static void main(String[] args) { DoubleList doubleList = new DoubleList(); for (int i = 0; i &lt;5 ; i++) { //doubleList.addFirst(i); doubleList.addLast(i); } doubleList.displayNext(); } 结果 1234501234 3.4 获取链表长度思路 ：遍历链表，一个节点代表一个单位的长度 1234567891011121314151617181920 /* * * @Author lsc * &lt;p&gt; 获得链表长度 * 思路：遍历链表，一个节点代表一个单位的长度 * &lt;/p&gt; * @Param [] * @Return int */public int length(){ int length = 0; // 当前节点 DoubleNode currentNode = head; while (currentNode!=null){ // 一个节点 length 长度就加1 length++; // 将下一个节点作为当前节点 currentNode = currentNode.getNext(); } return length;} 3.5 指定位置插入节点思路： 假设在BC直接插入新节点N B 节点的后续节点指向 N N 节点 的前驱节点指向 B N 节点的后续节点指向 C C 节点的前驱节点指向 N 重要的也就是要找到B节点的位置，转存C节点； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * * @Author lsc * &lt;p&gt; 指定位置插入节点 * 思路： 假设在AB直接插入新节点N * 1 A 节点的后续节点指向 N * 2 N 节点 的前驱节点指向 A * 3 N 节点的后续节点指向 B * 4 B 节点的前驱节点指向 N * 重点也是找到A节点的位置 * &lt;/p&gt; * @Param [data] * @Return void */ public void add(int data, int index){ // 索引超出，非法 if (index&lt;0 || index&gt;length()){ System.out.println(\"非法索引\"); return; } // 如果索引为0，调用addFirst方法 if (index==0){ addFirst(data); return; } // 如果索引等于链表的长度，调用addLast方法 if (index==length()){ addLast(data); return; } // 创建新节点 DoubleNode newNode = new DoubleNode(); // 为新节点添加数据 newNode.setData(data); // 当前节点 DoubleNode currentNode = head; // 定义指针 int point = 0; // 寻找插入新节点的上一个节点A while ((index-1)!= point){ currentNode = currentNode.getNext(); point++; } // 转存当前节点的后续节点 DoubleNode nextNode = currentNode.getNext(); // 当前节点的后续节点指向新节点 currentNode.setNext(newNode); // 新接的前驱节点指向当前节点 newNode.setPrevious(currentNode); // 新节点的后续节点指向转存的节点 newNode.setNext(nextNode); // 转存节点的前驱节点指向新节点 nextNode.setPrevious(newNode); } 测试代码 12345678public static void main(String[] args) { DoubleList doubleList = new DoubleList(); for (int i = 0; i &lt;5 ; i++) { doubleList.addLast(i); } doubleList.add(666,3); doubleList.displayNext();} 结果 12345601266634 3.6 删除表头思路如下 创建一个临时节点,存储表头的后续节点 将临时节点的前驱节点指向null 将临时节点赋值给表头 1234567891011121314151617181920212223242526/* * * @Author lsc * &lt;p&gt; 删除表头 思路： 1 创建一个临时节点,存储表头的后续节点 * 2 将临时节点的前驱节点指向null * 3 将临时节点赋值给表头 * &lt;/p&gt; * @Param [] * @Return void */ public void removeFirst(){ if (length()==0){ return; } // 只有一个节点直接清空表头 if (length()==1){ head=null; return; } // 创建一个临时节点,存储表头的后续节点 DoubleNode temNode = head.getNext(); // 将临时节点的前驱节点指向null temNode.setPrevious(null); // 将临时节点赋值给表头 head = temNode; } 测试代码 12345678public static void main(String[] args) { DoubleList doubleList = new DoubleList(); for (int i = 0; i &lt;5 ; i++) { doubleList.addLast(i); } doubleList.removeFirst(); doubleList.displayNext();} 结果 12341234 3.7 删除表尾思路 找到表尾的前驱节点 将表尾的前驱节点的后续节点置为null 1234567891011121314151617181920212223242526/* * * @Author lsc * &lt;p&gt; 删除表尾 思路： 1 找到表尾的前驱节点 * 2 将表尾的前驱节点的后续节点置为null * 3 * &lt;/p&gt; * @Param [] * @Return void */ public void removeLast(){ if (length()==0){ return; } // 只有一个节点直接清空表头 if (length()==1){ head=null; return; } DoubleNode previousNode = head; // 寻找尾节点的前驱节点 while (previousNode.getNext().getNext()!=null){ previousNode = previousNode.getNext(); } previousNode.setNext(null); } 测试代码 123456789public static void main(String[] args) { DoubleList doubleList = new DoubleList(); for (int i = 0; i &lt;5 ; i++) { //doubleList.addFirst(i); doubleList.addLast(i); } doubleList.removeLast(); doubleList.displayNext();} 结果 12340123 3.8 删除指定节点思路： 假设有BCD节点要删除B节点 将 B 节点的后续节点指向 D节点 将D节点前驱节点指向B节点 重要的也就是要找到B节点位置，转存D节点； 123456789101112131415161718192021222324252627282930313233343536373839404142/* * * @Author lsc * &lt;p&gt; 指定位置删除节点 思路： 假设有ABC节点要删除B节点 * 1 将 A 节点的后续节点指向 C节点 * 2 将C节点前驱节点指向A节点 * &lt;/p&gt; * @Param [index] * @Return void */ public void remove(int index){ if (index&lt;0 || index&gt;=length()){ System.out.println(\"非法索引\"); return; } // 头节点 if (index==0){ removeFirst(); return; } // 尾节点 if (index==(length()-1)){ removeLast(); return; } // 欲想删除节点的前驱节点 DoubleNode previousNode = head; // 定义指针 int point = 0; // 寻找新节 while ((index-1)!=point){ previousNode = previousNode.getNext(); point++; } // 欲想删除节点的后续节点 DoubleNode nextNode = previousNode.getNext().getNext(); // 将欲想删除节点的前驱节点的后续节点指向欲想删除节点的后续节点 previousNode.setNext(nextNode); // 将欲想删除节点的后续节点的前驱节点指向欲想删除节点的前驱节点 nextNode.setPrevious(previousNode); } 测试代码 123456789public static void main(String[] args) { DoubleList doubleList = new DoubleList(); for (int i = 0; i &lt;5 ; i++) { //doubleList.addFirst(i); doubleList.addLast(i); } doubleList.remove(3); doubleList.displayNext();} 结果 12340124","link":"/2020/07/12/数据结构与算法/java实现双向链表/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/数据结构与算法/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Python库","slug":"Python库","link":"/tags/Python库/"},{"name":"numpy","slug":"numpy","link":"/tags/numpy/"},{"name":"博客主题","slug":"博客主题","link":"/tags/博客主题/"},{"name":"Python语法","slug":"Python语法","link":"/tags/Python语法/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"U-net","slug":"U-net","link":"/tags/U-net/"},{"name":"卷积神经网络","slug":"卷积神经网络","link":"/tags/卷积神经网络/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"java语法","slug":"java语法","link":"/categories/java语法/"},{"name":"命令语法","slug":"命令语法","link":"/categories/命令语法/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"命令行与配置","slug":"命令行与配置","link":"/categories/命令行与配置/"},{"name":"深度学习","slug":"深度学习","link":"/categories/深度学习/"}]}